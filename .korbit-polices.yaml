version: "0.1"

topics:
  - name: "API Version Pinning & Upgrade Strategy"
    paths:
      - '**/*.py'
      - '**/*.js'
      - '**/*.ts'
    policies:
    - title: "Explicit Stripe API Version Declaration"
      severity: High
      required_context: Single-File
      software_version: all
      reference_link:
        - https://stripe.com/docs/api/versioning
      description: |
        Stripe API version must be explicitly declared in code via the SDK or HTTP headers.

        Omitting this risks unexpected behavior if Stripe updates the default API version for your account.
      impact: |
        - Ensures consistent behavior across environments.
        - Prevents unintentional breaking changes due to default version upgrades.
      code_examples:
        # Python — NON-COMPLIANT: No explicit API version set; uses Stripe's default
        - non_compliant: |
            import stripe

            stripe.api_key = "sk_live_12345abcde"
            # No stripe.api_version specified; defaults to account-level version

        # Python — COMPLIANT: API version explicitly set using Stripe SDK
        - compliant: |
            import stripe

            stripe.api_key = "sk_live_12345abcde"
            stripe.api_version = "2025-06-15"

    - title: "Explicit Stripe API Version Pinning"
      severity: High
      required_context: Single-File
      software_version: all
      reference_link:
        - https://stripe.com/docs/api/versioning
      description: |
        All Stripe integrations must explicitly declare the API version used via SDK configuration or headers.

        This prevents future breaking changes caused by automatic upgrades of the default Stripe API version.
      impact: |
        - Ensures predictable and stable behavior of Stripe APIs.
        - Avoids unexpected errors due to unpinned API upgrades.
      code_examples:
        # Python — NON-COMPLIANT: No API version pinned
        - non_compliant: |
            import stripe

            stripe.api_key = "sk_test_..."
            # No stripe.api_version specified

        # Python — COMPLIANT: Stripe API version pinned
        - compliant: |
            import stripe

            stripe.api_key = "sk_test_..."
            stripe.api_version = "2024-08-01"

    - title: "Stripe API Version Lock Tracking"
      severity: Medium
      required_context: Single-File
      software_version: all
      reference_link:
        - https://stripe.com/docs/changelog
      description: |
        Projects using Stripe must maintain a version-lock file or changelog to track the API version in use.

        This file (e.g., `stripe_api_version.txt` or `CHANGELOG.md`) must record the pinned API version and any related changes.
      impact: |
        - Enables safe upgrades by documenting version history.
        - Helps teams audit API version changes across environments.
      code_examples:
        # Python — NON-COMPLIANT: No changelog or version tracking
        - non_compliant: |
            import stripe

            stripe.api_key = "sk_test_..."
            stripe.api_version = "2024-08-01"
            # But version not tracked in any version-lock or changelog file

        # Python — COMPLIANT: Version tracked in separate lock file
        - compliant: |
            import stripe

            stripe.api_key = "sk_test_..."
            stripe.api_version = "2024-08-01"

            # stripe_api_version.txt file content:
            # 2024-08-01

            # Alternatively, version tracking in changelog.md:
            # - 2024-08-01: Upgraded Stripe API version from 2023-11-01

    - title: "Explicit Stripe API Version Declaration"
      severity: High
      required_context: Single-File
      software_version: all
      reference_link:
        - https://stripe.com/docs/changelog
      description: |
        Stripe API version upgrades must include an explicit version in code and a nearby comment block documenting the upgrade rationale and rollback strategy.
      impact: |
        - Ensures that API version upgrades are intentional and documented.
        - Encourages traceability and minimizes regression risk.
      code_examples:
        # Python — NON-COMPLIANT: Missing rationale and rollback documentation
        - non_compliant: |
            import stripe

            stripe.api_key = "sk_test_..."
            stripe.api_version = "2025-07-01"

            customer = stripe.Customer.create(email="user@example.com")

        # Python — COMPLIANT: Version upgrade with rationale and rollback notes
        - compliant: |
            import stripe

            stripe.api_key = "sk_test_..."
            stripe.api_version = "2025-07-01"  # Upgraded to access new PaymentIntent behavior
            # Rationale: This upgrade enables support for automatic_payment_methods
            # Rollback plan: Revert to "2022-11-15" and remove auto-payment-related fields

            customer = stripe.Customer.create(email="user@example.com")

    - title: "Use Stripe Test API Keys in Test Files"
      severity: High
      required_context: Single-File
      software_version: all
      reference_link:
        - https://stripe.com/docs/keys
        - https://stripe.com/docs/testing
      description: |
        Test files that call Stripe SDK methods must use test-mode API keys (those starting with `sk_test_`).

        This ensures tests do not trigger real charges or modify live account data.
      impact: |
        - Prevents accidental interaction with live customer or payment data.
        - Avoids real charges from test execution environments.
      code_examples:
        # Python — NON-COMPLIANT: Live secret key used in test
        - non_compliant: |
            import stripe

            stripe.api_key = "sk_live_..."  # Should be a test key

            def test_customer_creation():
                stripe.Customer.create(email="user@example.com")

        # Python — COMPLIANT: Test key used for Stripe integration in test
        - compliant: |
            import stripe

            stripe.api_key = "sk_test_..."

            def test_customer_creation():
                stripe.Customer.create(email="user@example.com")

    - title: "Pin Stripe API Version in Test Files"
      severity: High
      required_context: Single-File
      software_version: all
      reference_link:
        - https://stripe.com/docs/api/versioning
      description: |
        Test files that use the Stripe SDK must explicitly declare the Stripe API version used.

        This prevents tests from breaking due to future Stripe API version changes.
      impact: |
        - Improves test reliability across environments and CI/CD runs.
        - Ensures tests reflect and validate behavior for a known API version.
      code_examples:
        # Python — NON-COMPLIANT: API version not declared in test
        - non_compliant: |
            import stripe

            stripe.api_key = "sk_test_..."

            def test_customer_creation():
                stripe.Customer.create(email="user@example.com")

        # Python — COMPLIANT: Stripe API version declared
        - compliant: |
            import stripe

            stripe.api_key = "sk_test_..."
            stripe.api_version = "2025-06-01"

            def test_customer_creation():
                stripe.Customer.create(email="user@example.com")

    - title: "In-Code Stripe API Rollback Support"
      severity: High
      required_context: Single-File
      software_version: all
      reference_link:
        - https://stripe.com/docs/upgrades#rollback
      description: |
        When upgrading the Stripe API version in code, you must include logic, conditionals, or a documented comment that supports rollback to a prior version.
      impact: |
        - Enables fast reversion of API version changes through clear in-repo logic.
        - Minimizes production downtime and operational risk.
        - Encourages safe upgrade practices by embedding rollback awareness in code.
      code_examples:
        # Python — NON-COMPLIANT: Version is updated but no rollback strategy is included
        - non_compliant: |
            import stripe

            stripe.api_key = "sk_test_..."
            stripe.api_version = "2025-07-01"

        # Python — COMPLIANT: Includes rollback awareness via config and inline comment
        - compliant: |
            import stripe
            import json

            stripe.api_key = "sk_test_..."

            with open("config.json") as f:
                config = json.load(f)
                stripe.api_version = config.get("stripe_version", "2025-06-01")

            # Rollback plan: to revert, change `stripe_version` in config.json to "2025-06-01"

    - title: "In-Repo Stripe API Upgrade Documentation"
      severity: High
      required_context: Single-File
      software_version: all
      reference_link:
        - https://stripe.com/docs/upgrades#preparation
      description: |
        When upgrading Stripe API versions in code, you must document the version number and affected endpoints in a clearly marked code comment near the version change.
      impact: |
        - Ensures developers are aware of behavior changes tied to API versions.
        - Encourages traceability of breaking changes in the repo itself.
        - Promotes good upgrade hygiene directly within the codebase.
      code_examples:
        - # Python — NON-COMPLIANT: Stripe API version changed with no associated documentation
          non_compliant: |
            import stripe

            stripe.api_key = "sk_test_..."
            stripe.api_version = "2025-08-01"

        - # Python — COMPLIANT: Version upgrade is paired with inline upgrade notes
          compliant: |
            import stripe

            stripe.api_key = "sk_test_..."
            stripe.api_version = "2025-08-01"

            # Stripe API upgrade 2025-08-01:
            # - /v1/payment_intents: New capture_method default
            # - /v1/webhooks: Now supports expand[]=data.customer

    - title: "Periodic Audit & Compliance Check"
      severity: Medium
      required_context: Single-File
      software_version: all
      reference_link:
        - https://stripe.com/docs/upgrades#versioning
      description: |
        All Stripe integrations must explicitly specify API versions in code and configuration files using `stripe.api_version` or `?api_version=YYYY-MM-DD`. This applies across services and environments.
      impact: |
        - Surfaces systems unintentionally inheriting default Stripe API versions
        - Enforces consistency across services and teams
        - Reduces risk of unexpected behavior due to silent upgrades
      code_examples:
        # Python — NON-COMPLIANT: Stripe API version not set
        - non_compliant: |
            import stripe

            stripe.api_key = "sk_test_..."
            # Missing: stripe.api_version assignment
            customer = stripe.Customer.create(email="test@example.com")

        # Python — COMPLIANT: Explicitly sets API version
        - compliant: |
            import stripe

            stripe.api_key = "sk_test_..."
            stripe.api_version = "2025-08-01"  # Explicit version pin

            customer = stripe.Customer.create(email="test@example.com")

  - name: "Secret Key Management & Environment Separation"
    paths:
      - '**/*.py'
      - '**/*.js'
      - '**/*.ts'
      - '**/*.env'
      - '**/config*.yml'
      - '**/config*.json'
      - '.github/workflows/**/*.yml'
    policies:
    - title: "No Hardcoded Stripe Secret Keys"
      severity: High
      required_context: Environment & Secrets Configuration
      software_version: all
      reference_link:
        - https://stripe.com/docs/keys
        - https://12factor.net/config
      description: |
        Stripe secret keys must not be hardcoded in source code. Keys must be loaded from environment variables or configuration files that are excluded from version control (e.g. via `.gitignore`).
      impact: |
        - Prevents accidental exposure of sensitive API keys in repositories or logs
        - Enables secure key rotation and management
      code_examples:
        # Python — NON-COMPLIANT: Hardcoded secret key in application code
        - non_compliant: |
            # config.py
            import stripe
            stripe.api_key = "sk_live_1234567890abcdef"  # Hardcoded secret key

        # .env — NON-COMPLIANT: Key stored in .env file that is committed to version control
        - non_compliant: |
            # .env (committed to Git repository)
            STRIPE_API_KEY=sk_test_9876543210fedcba

        # Python — COMPLIANT: Key loaded securely from environment variable
        - compliant: |
            import os
            import stripe

            stripe.api_key = os.environ["STRIPE_API_KEY"]

        # .env — COMPLIANT: .env file containing the secret key (not checked into version control)
        - compliant: |
            # .env (excluded via .gitignore)
            STRIPE_API_KEY=sk_test_abc1234567890

    - title: "Environment-Specific Stripe Keys"
      severity: High
      required_context: Environment & Secrets Configuration
      software_version: all
      reference_link:
        - https://stripe.com/docs/keys#best-practices
      description: |
        Each environment (e.g., development, staging, production) must use a distinct Stripe secret key, configured via environment-specific environment variables or configuration files.
      impact: |
        - Prevents secrets from being leaked or reused across environments
        - Reduces scope of compromise if credentials are exposed
      code_examples:
        # Python — NON-COMPLIANT: Same secret key reused in all environments
        - non_compliant: |
            import os
            import stripe

            # STRIPE_API_KEY is set to the same value in dev, staging, and prod
            stripe.api_key = os.getenv("STRIPE_API_KEY", "sk_live_shared_key_for_all_envs")

            def process_payment():
                stripe.PaymentIntent.create(amount=1000, currency="usd")

        # .env.dev — COMPLIANT: Unique test key for dev environment
        - compliant: |
            STRIPE_API_KEY=sk_test_dev_key_123

        # .env.staging — COMPLIANT: Unique test key for staging
        - compliant: |
            STRIPE_API_KEY=sk_test_staging_key_456

        # .env.prod — COMPLIANT: Unique live key for production
        - compliant: |
            STRIPE_API_KEY=sk_live_prod_key_789

        # Python — COMPLIANT: Key is loaded from environment, varies by environment context
        - compliant: |
            import os
            import stripe

            stripe.api_key = os.environ["STRIPE_API_KEY"]

            def process_payment():
                stripe.PaymentIntent.create(amount=1000, currency="usd")

    - title: "Key Rotation Policy"
      severity: High
      required_context: Environment & Secrets Configuration
      software_version: all
      reference_link:
        - https://stripe.com/docs/keys#rotating
        - https://docs.aws.amazon.com/secretsmanager/latest/userguide/rotating-secrets.html
        - https://cloud.google.com/secret-manager/docs/rotation
      description: |
        Application code must retrieve Stripe API keys dynamically from environment variables or secret managers at runtime. Do not hardcode or cache keys.
      impact: |
        - Allows safe, seamless secret rotation without deployment delays
        - Minimizes manual intervention during security incidents
        - Aligns application behavior with cloud rotation automation
      code_examples:
        - # Python — NON-COMPLIANT: Stripe key is hardcoded and not reloadable
          non_compliant: |
            import stripe
            stripe.api_key = "sk_live_ABC123"  # hardcoded secret

        - # Python — COMPLIANT: Stripe key loaded from env each time
          compliant: |
            import os
            import stripe

            def initialize_stripe():
                stripe.api_key = os.getenv("STRIPE_API_KEY")  # supports rotation

    - title: "Do Not Hardcode Keys"
      severity: High
      required_context: Environment & Secrets Configuration
      software_version: all
      reference_link:
        - https://stripe.com/docs/security/guide#api-keys
        - https://12factor.net/config
      description: |
        Stripe secret keys must never be hardcoded in source files, committed to version control, or embedded in configuration files such as Dockerfiles or scripts.
      impact: |
        - Prevents accidental or malicious exposure of secrets via source control
        - Reduces blast radius in the event of a compromised repository or developer machine
        - Promotes centralized secret management and traceable access
      code_examples:
        # Python, Dockerfile — NON-COMPLIANT: Keys hardcoded in source/config files
        - non_compliant: |
            # Hardcoded in Python
            stripe.api_key = "sk_live_1234567890"

            # Committed in Dockerfile
            ENV STRIPE_KEY="sk_live_1234567890"

        # Node.js, AWS SDK — COMPLIANT: Secure retrieval and usage of Stripe keys
        - compliant: |
            # Node.js with format validation
            const stripeKey = process.env.STRIPE_SECRET_KEY;
            if (!/^sk_(live|test)_[a-zA-Z0-9]{24}$/.test(stripeKey)) {
              throw new Error('Invalid Stripe key format');
            }
            const stripe = require("stripe")(stripeKey);

            # AWS Secrets Manager usage with error handling
            const { SecretsManager } = require('aws-sdk');
            const sm = new SecretsManager();
            try {
              const secret = await sm.getSecretValue({
                SecretId: 'prod/stripe/key'
              }).promise();
              const stripe = require("stripe")(secret.SecretString);
            } catch (err) {
              console.error('Failed to retrieve Stripe key:', err);
              process.exit(1);
            }

            # Local development safety
            # .gitignore
            .env.local

            # .env.local (NOT committed)
            STRIPE_KEY=sk_test_xxxxxxxxxxxx
    
    - title: "Environment-Specific Stripe Key Configuration"
      severity: High
      required_context: Environment & Secrets Configuration
      software_version: all
      reference_link:
        - https://stripe.com/docs/keys#test-live-modes
        - https://stripe.com/docs/best-practices#environments
      description: |
        Stripe credentials must be configured separately for each environment (e.g., development, staging, production) using isolated environment-specific variables or secret management. Code must load and apply credentials based on the current runtime environment.
      impact: |
        - Prevents accidental exposure of live keys in non-production environments
        - Encourages configuration isolation and separation of concerns
        - Reduces risk of test data polluting production systems
      code_examples:
        - # Python — NON-COMPLIANT: Same variable used across all environments
          non_compliant: |
            import stripe
            import os

            stripe.api_key = os.getenv("STRIPE_SECRET_KEY")  # No environment separation

        - # Python — COMPLIANT: Loads Stripe keys based on environment
          compliant: |
            import os
            from dotenv import load_dotenv
            import stripe

            env = os.getenv("APP_ENV", "dev")
            load_dotenv(f".env.{env}")

            stripe.api_key = os.getenv("STRIPE_SECRET_KEY")
            stripe_webhook_secret = os.getenv("STRIPE_WEBHOOK_SECRET")

    - title: "Environment-Specific Secret Configuration"
      severity: High
      required_context: Environment & Secrets Configuration
      software_version: all
      reference_link:
        - https://stripe.com/docs/keys#test-live-modes
        - https://cloud.google.com/secret-manager/docs
      description: |
        Maintain isolated secret identifiers for each environment (development, staging, production). Secrets must follow naming conventions that include the environment name.
      impact: |
        - Prevents accidental use of production credentials in non-production systems
        - Simplifies access control, auditing, and automated validation
        - Makes automation and secret rotation safer and easier to manage
      code_examples:
        # JSON — NON-COMPLIANT: Shared identifier across environments
        - non_compliant: |
            {
              "stripe_secret": "projects/global/secrets/STRIPE_API_KEY"
            }

        # Python — COMPLIANT: Isolated secrets per environment using naming convention
        - compliant: |
            import os

            env = os.getenv("APP_ENV", "dev")
            if env not in ("dev", "staging", "prod"):
                raise ValueError(f"Invalid environment: {env}")

            secret_id = f"{env.upper()}_STRIPE_API_KEY"

            def fetch_stripe_key():
                from google.cloud import secretmanager
                client = secretmanager.SecretManagerServiceClient()
                name = f"projects/my-project/secrets/{secret_id}/versions/latest"
                response = client.access_secret_version(name=name)
                return response.payload.data.decode("UTF-8")

    - title: "Environment-Aware Secret Referencing in Code"
      severity: High
      required_context: Environment & Secrets Configuration
      software_version: all
      reference_link:
        - https://stripe.com/docs/keys#environment
        - https://docs.aws.amazon.com/secretsmanager/latest/userguide/best-practices.html
      description: |
        Stripe-related secrets must be referenced in code using environment-specific identifiers. Code must construct or select secret names based on the current runtime environment (e.g., `dev`, `staging`, `prod`).
      impact: |
        - Ensures correct secret is fetched for the current environment
        - Prevents production secrets from being used in development or staging
        - Enables consistent and auditable secret access patterns in code
      code_examples:
        - # Python — NON-COMPLIANT: Hardcoded secret name without environment context
          non_compliant: |
            import boto3
            client = boto3.client('secretsmanager')
            secret = client.get_secret_value(SecretId="stripe_api_key")

        - # Python — COMPLIANT: Secret name includes environment context
          compliant: |
            import os
            import boto3

            env = os.getenv("APP_ENV", "dev")  # e.g., "dev", "staging", "prod"
            secret_id = f"{env}_payments_stripe_api_key"

            client = boto3.client("secretsmanager")
            secret = client.get_secret_value(SecretId=secret_id)

    - title: "Environment-Based Stripe Key Validation"
      severity: High
      required_context: Environment & Secrets Configuration
      software_version: all
      reference_link:
        - https://stripe.com/docs/keys
        - https://12factor.net/config
      description: |
        Stripe secret keys must be validated in application code for environment-specific key format compliance.
      impact: |
        - Prevents runtime errors due to misconfigured keys
        - Enables consistent secret validation within codebase
        - Reduces accidental use of live credentials in test or staging
      code_examples:
        # Node.js — NON-COMPLIANT: No validation of key format
        - non_compliant: |
            const stripe = require("stripe")(process.env.STRIPE_SECRET_KEY);

        # Node.js — COMPLIANT: Environment-aware format validation
        - compliant: |
            const stripeKey = process.env.STRIPE_SECRET_KEY;
            const env = process.env.NODE_ENV;

            if (
              (env === 'production' && !/^sk_live_[a-zA-Z0-9]{24}$/.test(stripeKey)) ||
              (env !== 'production' && !/^sk_test_[a-zA-Z0-9]{24}$/.test(stripeKey))
            ) {
              throw new Error(`Invalid Stripe key format for environment: ${env}`);
            }

            const stripe = require("stripe")(stripeKey);

    - title: "Data Contamination Prevention"
      severity: High
      required_context: Environment & Secrets Configuration
      software_version: all
      reference_link:
        - https://stripe.com/docs/testing
        - https://stripe.com/docs/security
      description: |
        Do not use production Stripe API keys or real customer data in non-production environments. All test and staging code must use test-mode keys (`sk_test_`) and mock or randomized data.
      impact: |
        - Prevents accidental exposure of sensitive information
        - Ensures that only test-mode keys are used in development
        - Reduces risk of violating compliance standards (e.g., GDPR, PCI-DSS)
      code_examples:
        # Python — NON-COMPLIANT: Hardcoded live key in test environment
        - non_compliant: |
            stripe.api_key = "sk_live_abc123"
            stripe.Charge.create(
              amount=1000,
              currency="usd",
              source="tok_visa",
              description="Real customer: cust_123"
            )

        # Python — COMPLIANT: Environment-aware test key validation
        - compliant: |
            import os
            import stripe

            env = os.getenv("ENVIRONMENT", "dev")
            stripe_key = os.getenv("STRIPE_KEY")

            if env != "prod" and stripe_key.startswith("sk_live_"):
                raise ValueError(f"Non-production environment '{env}' must not use live Stripe keys.")

            stripe.api_key = stripe_key

            test_customer = {
              "email": f"test_user_{os.getpid()}@example.com",
              "source": "tok_visa"
            }
            stripe.Charge.create(
              amount=1000,
              currency="usd",
              source=test_customer["source"],
              description="Test transaction"
            )

  - name: "Secure Payment Collection Using Stripe Elements / Payment Element"
    paths:
      - '**/*.js'
      - '**/*.ts'
      - '**/*.tsx'
      - '**/*.jsx'
      - '**/checkout/**/*'
      - '**/payments/**/*'
      - "**/*.html"
      - "**/*.py"
    policies:
    - title: "Use Stripe SDK Components for Payment Data"
      severity: High
      required_context: Payment Collection Method
      software_version: all
      reference_link:
        - https://docs.stripe.com/payments/quickstart
        - https://docs.stripe.com/elements
      description: |
        Collect all payment details using Stripe SDK components such as Elements, PaymentElement, or mobile SDKs. Do not define custom input fields that collect raw card numbers, expiry dates, or CVC codes.
      impact: |
        - Avoids handling sensitive payment data directly in application code
        - Maintains PCI DSS SAQ A compliance
        - Provides a secure, consistent integration pattern
      code_examples:
        # HTML — NON-COMPLIANT: Custom card input fields
        - non_compliant: |
            <!-- Dangerous custom form -->
            <form id="payment-form">
              <input type="text" name="cardnumber" placeholder="Card number">
              <input type="text" name="expiry" placeholder="MM/YY">
              <input type="text" name="cvc" placeholder="CVC">
            </form>

        # HTML — COMPLIANT: Stripe.js mounts secure card element
        - compliant: |
            <!-- Stripe.js secure card element -->
            <form id="payment-form">
              <div id="card-element"><!-- Stripe injects secure iframe here --></div>
              <button type="submit">Pay</button>
            </form>
            <script src="https://js.stripe.com/v3/"></script>
            <script>
              const stripe = Stripe('pk_test_...');
              const elements = stripe.elements();
              const card = elements.create('card');
              card.mount('#card-element');
            </script>

        # React (JavaScript) — COMPLIANT: Stripe CardElement
        - compliant: |
            import {CardElement} from '@stripe/react-stripe-js';
            function CheckoutForm() {
              return (
                <form>
                  <CardElement options={{style: {base: {fontSize: '16px'}}}} />
                </form>
              );
            }

        # Python — NON-COMPLIANT: Handling raw card data
        - non_compliant: |
            # DO NOT accept raw card data in backend
            import stripe
            def process_payment(request):
                card_number = request.POST["card_number"]  # ❌ Never handle raw card data
                stripe.Token.create(card={"number": card_number})

        # Kotlin (Android) — COMPLIANT: Full Stripe PaymentSheet usage
        - compliant: |
            // Inside your Activity or Fragment
            val paymentSheet = PaymentSheet(this, ::onPaymentSheetResult)

            val configuration = PaymentSheet.Configuration(
                merchantDisplayName = "My Store",
                customer = PaymentSheet.CustomerConfiguration(
                    id = "cus_123",
                    ephemeralKeySecret = "ek_test_..."
                )
            )

            val clientSecret = "pi_12345_secret_67890"

            // Launch the PaymentSheet
            payButton.setOnClickListener {
                paymentSheet.presentWithPaymentIntent(
                    clientSecret,
                    configuration
                )
            }

            private fun onPaymentSheetResult(paymentResult: PaymentSheetResult) {
                when (paymentResult) {
                    is PaymentSheetResult.Completed -> {
                        // Payment succeeded
                    }
                    is PaymentSheetResult.Canceled -> {
                        // Payment canceled
                    }
                    is PaymentSheetResult.Failed -> {
                        // Payment failed
                    }
                }
            }

    - title: "Disable Direct Card Data Handling"
      severity: High
      required_context: Payment Collection Method
      software_version: all
      reference_link:
        - https://docs.stripe.com/security/guide#pci-compliance
        - https://docs.stripe.com/elements
      description: |
        Prohibit any frontend code from accessing, storing, or transmitting raw payment card data.
        All payment inputs must be handled exclusively through Stripe-hosted components.
      impact: |
        - Maintains PCI DSS SAQ A compliance by ensuring card data never touches your systems
        - Prevents accidental logging or exposure of sensitive payment information
        - Reduces risk of non-compliance during audits and security reviews
      code_examples:
        # JavaScript — NON-COMPLIANT: Accessing raw card data
        - non_compliant: |
            // Dangerous card data access
            document.querySelector('#cc-form').addEventListener('submit', (e) => {
              const cardData = {
                number: e.target.cardNumber.value,
                cvc: e.target.cvv.value  // PCI violation!
              };
              processPayment(cardData);
            });

            // Unsafe React state handling
            function PaymentForm() {
              const [cardNumber, setCardNumber] = useState(''); // Never store card data in state
              return <input value={cardNumber} onChange={...} />
            }

        # React (JavaScript) — COMPLIANT: Secure use of Stripe Elements
        - compliant: |
            import {CardElement, useStripe, useElements} from '@stripe/react-stripe-js';
            
            function Checkout() {
              const stripe = useStripe();
              const elements = useElements();

              const handleSubmit = async () => {
                const cardElement = elements.getElement(CardElement);
                const {error, paymentMethod} = await stripe.createPaymentMethod({
                  type: 'card',
                  card: cardElement
                });
                if (error) {
                  console.log('Payment error:', error.message);
                }
              };

              return (
                <form onSubmit={handleSubmit}>
                  <CardElement />
                  <button type="submit">Pay</button>
                </form>
              );
            }

    - title: "Enforce SCA (Strong Customer Authentication)"
      severity: High
      required_context: Payment Flow Implementation
      software_version: all
      reference_link:
        - https://docs.stripe.com/payments/strong-customer-authentication
        - https://docs.stripe.com/payments/payment-intents
      description: |
        Use Stripe's PaymentIntents API to support Strong Customer Authentication (SCA). Do not use the deprecated Charges API. Ensure client-side flows complete 3D Secure authentication challenges using Stripe Elements or PaymentElement.
      impact: |
        - Maintains compliance with PSD2 and SCA regulations
        - Reduces fraud by verifying customers with 3D Secure
        - Prevents payment failures from unhandled SCA challenges
      code_examples:
        - # JavaScript — NON-COMPLIANT: Using Charges API (no SCA support)
          non_compliant: |
            const stripe = require('stripe')('sk_test_...');

            stripe.charges.create({
              amount: 1000,
              currency: 'eur',
              source: 'tok_visa',
              description: 'Basic charge without SCA'
            });

        - # Python — NON-COMPLIANT: Using Charges API (no SCA support)
          non_compliant: |
            import stripe
            stripe.api_key = "sk_test_..."
            stripe.Charge.create(
                amount=1000,
                currency="eur",
                source="tok_visa",
                description="Basic charge without SCA"
            )

        - # JavaScript — COMPLIANT: Backend PaymentIntent creation
          compliant: |
            const stripe = require('stripe')('sk_test_...');
            async function createPaymentIntent() {
              const intent = await stripe.paymentIntents.create({
                amount: 1000,
                currency: 'eur',
                payment_method_types: ['card'],
                confirm: false,
              });
              return intent.client_secret;
            }

        - # JavaScript — COMPLIANT: Client-side SCA handling using Elements
          compliant: |
            import {loadStripe} from '@stripe/stripe-js';
            import {Elements, CardElement, useStripe, useElements} from '@stripe/react-stripe-js';

            const stripePromise = loadStripe('pk_test_...');

            function CheckoutForm({clientSecret}) {
              const stripe = useStripe();
              const elements = useElements();

              const handleSubmit = async (event) => {
                event.preventDefault();
                const result = await stripe.confirmCardPayment(clientSecret, {
                  payment_method: {
                    card: elements.getElement(CardElement),
                  }
                });

                if (result.error) {
                  console.error('Payment failed:', result.error.message);
                } else if (result.paymentIntent.status === 'succeeded') {
                  console.log('Payment succeeded!');
                }
              };

              return (
                <form onSubmit={handleSubmit}>
                  <CardElement />
                  <button type="submit" disabled={!stripe}>Pay</button>
                </form>
              );
            }

        - # HTML — COMPLIANT: Stripe.js with PaymentIntent and 3D Secure
          compliant: |
            <!-- Stripe.js SCA-compliant payment form -->
            <form id="payment-form">
              <div id="card-element"></div>
              <button id="submit">Pay</button>
            </form>
            <script src="https://js.stripe.com/v3/"></script>
            <script>
              var stripe = Stripe('pk_test_...');
              var elements = stripe.elements();
              var card = elements.create('card');
              card.mount('#card-element');
              document.getElementById('payment-form').addEventListener('submit', async function(e) {
                e.preventDefault();
                const {error, paymentIntent} = await stripe.confirmCardPayment(
                  'CLIENT_SECRET_FROM_BACKEND',
                  {payment_method: {card: card}}
                );
                if (error) {
                  alert(error.message);
                } else if (paymentIntent.status === 'succeeded') {
                  alert('Payment succeeded!');
                }
              });
            </script>

    - title: "Load Stripe.js Exclusively from Official Stripe CDN"
      severity: High
      required_context: Client-side payment implementations (Elements/PaymentElement/Checkout)
      software_version: all
      reference_link:
        - https://docs.stripe.com/js
        - https://stripe.com/docs/security#content-security-policy
      description: |
        Stripe.js must always be loaded directly from https://js.stripe.com/v3/ with no intermediary proxies,
        local copies, or alternative CDNs. This applies to all implementations using:
        - Stripe Elements
        - Payment Element
        - Checkout (client-side)
        - Identity verification flows
      impact: |
        Guarantees automatic security updates, prevents MITM attacks, and ensures PCI DSS compliance.
        Non-compliant implementations may:
        - Invalidate Stripe's security certifications
        - Expose payment data to interception
        - Break automatic fraud detection features
      code_examples:
        - # HTML (compliant)
          compliant: |
            <!-- COMPLIANT: Official Stripe CDN -->
            <head>
              <script src="https://js.stripe.com/v3/"></script>
            </head>
        - # JavaScript (compliant)
          compliant: |
            // COMPLIANT: Framework-specific wrapper
            import {loadStripe} from '@stripe/stripe-js'
        - # HTML (non-compliant)
          non_compliant: |
            <!-- NON-COMPLIANT: Local copy -->
            <script src="/assets/js/stripe.js"></script>

            <!-- NON-COMPLIANT: Unverified CDN -->
            <script src="https://cdn.example.com/stripe/v3.js"></script>
        - # JavaScript (non-compliant)
          non_compliant: |
            // NON-COMPLIANT: NPM without version pinning
            import Stripe from 'unverified-stripe-package'
        - # Python (compliant — Django template)
          compliant: |
            # views.py
            from django.shortcuts import render

            def checkout_view(request):
                return render(request, 'checkout.html')

            <!-- checkout.html -->
            <!DOCTYPE html>
            <html>
              <head>
                <!-- COMPLIANT: Load Stripe.js from official CDN -->
                <script src="https://js.stripe.com/v3/"></script>
              </head>
              <body>
                <h1>Secure Checkout</h1>
              </body>
            </html>
        - # Python (compliant — Flask route)
          compliant: |
            # app.py
            from flask import Flask, render_template

            app = Flask(__name__)

            @app.route("/checkout")
            def checkout():
                return render_template("checkout.html")

            <!-- templates/checkout.html -->
            <!DOCTYPE html>
            <html>
              <head>
                <!-- COMPLIANT: Load Stripe.js from official CDN -->
                <script src="https://js.stripe.com/v3/"></script>
              </head>
              <body>
                <h1>Stripe Checkout Page</h1>
              </body>
            </html>

    - title: "PCI-Compliant Cardholder Data Handling Restrictions"
      severity: Mandatory
      required_context: All payment processing flows (client/server/webhooks)
      software_version: all
      reference_link:
        - https://docs.stripe.com/security/guide#handling-card-data
        - https://stripe.com/docs/security/secure-with-stripe
      description: |
        Never process, store, or log raw cardholder data (CHD) in application code. Only use Stripe SDK components such as Elements, Checkout, or Payment Links to collect payment details.
      impact: |
        Non-compliance breaks PCI DSS scope and triggers severe consequences:
        - Fines of $5,000–$100,000/month from card networks
        - Mandatory forensic audits (PFI)
        - Stripe account suspension or termination
      code_examples:
        - # JavaScript (compliant)
          compliant: |
            // SAFE: Frontend tokenization using Stripe Elements
            const { paymentMethod } = await stripe.createPaymentMethod({
              type: 'card',
              card: elements.getElement('card'),
            });

        - # Node.js (compliant)
          compliant: |
            // SAFE: Backend only uses tokenized paymentMethodId
            const paymentIntent = await stripe.paymentIntents.create({
              amount: 1000,
              currency: 'usd',
              payment_method: req.body.paymentMethodId,
              confirm: true,
            });

        - # JavaScript (non-compliant)
          non_compliant: |
            // VIOLATION: Accepting raw card data on the server
            app.post('/process-payment', (req, res) => {
              stripe.tokens.create({
                card: {
                  number: req.body.cardNumber,  // ❌ Raw CHD
                  cvc: req.body.cvv,
                  exp_month: req.body.expMonth,
                  exp_year: req.body.expYear
                }
              });
            });

        - # Python (non-compliant)
          non_compliant: |
            # VIOLATION: Logging raw card number
            print(f"Processing card: {request.POST['card_number']}")  # ❌ PCI breach

  - name: "PCI Compliance & Tokenization Sub-Policies"
    paths:
      - '**/frontend/**'
      - '**/payments/**'
      - '**/checkout/**'
      - '**/components/Stripe/**'
      - '**/backend/**'
    policies:
    - title: "Enforce Client-Side Tokenization for Payment Data"
      severity: Mandatory
      required_context: All payment collection interfaces
      software_version: all
      reference_link:
        - https://docs.stripe.com/payments/accept-a-payment
        - https://docs.stripe.com/security/guide#handling-card-data
      description: |
        All payment data must be tokenized on the client using Stripe SDK components. Do not process or tokenize raw card data on the server.
      impact: |
        Failure to use client-side tokenization exposes your system to raw cardholder data and increases PCI scope.

        Violations can result in:
        - Ineligibility for simplified PCI SAQ A or SAQ A-EP
        - Mandatory shift to SAQ D compliance (~$50,000+ annually)
        - Potential Stripe account suspension
        - Required forensic investigation in the event of a breach
        - Loss of customer trust and regulatory penalties

      code_examples:
        - # Python (compliant)
          compliant: |
            # Frontend handles tokenization — backend receives tokenized reference only
            import stripe
            stripe.api_key = "sk_test_..."

            payment_intent = stripe.PaymentIntent.create(
                amount=1999,
                currency='usd',
                payment_method="pm_card_visa",  # received from frontend
                confirmation_method="manual",
                confirm=True
            )
            print(payment_intent.status)

        - # JavaScript (compliant)
          compliant: |
            // Modern PaymentMethod flow (recommended)
            const { paymentMethod, error } = await stripe.createPaymentMethod({
              type: 'card',
              card: elements.getElement('card'),
              billing_details: { email: 'customer@example.com' }
            });

        - # JavaScript (non-compliant)
          non_compliant: |
            // PCI VIOLATION: Server-side token creation
            app.post('/dangerous_endpoint', async (req, res) => {
              const token = await stripe.tokens.create({
                card: {
                  number: req.body.cardNumber,  // PAN exposure
                  exp_month: req.body.expMonth,
                  exp_year: req.body.expYear,
                  cvc: req.body.cvv             // High-risk violation
                }
              });
            });

        - # Python (non-compliant)
          non_compliant: |
            # DO NOT use server-side card tokenization
            import stripe
            stripe.api_key = "sk_test_..."

            token = stripe.Token.create(
                card={
                    "number": "4242424242424242",   # PAN directly handled
                    "exp_month": 12,
                    "exp_year": 2025,
                    "cvc": "123"
                }
            )
            print(token.id)  # Logging a token from raw CHD input is not allowed

    - title: "Prohibited Storage of Sensitive Payment Data"
      severity: Critical
      required_context: All backend systems (servers, databases, logging)
      software_version: all
      reference_link:
        - https://docs.stripe.com/security/guide#handling-card-data
        - https://stripe.com/docs/security#never-store-card-data
      description: |
        Never store, log, or cache raw cardholder data (PAN, CVV, track data, PIN) in any system. Only use tokenized references or truncated card details where permitted.
      impact: |
        Violations result in:
        - Immediate PCI DSS non-compliance
        - Mandatory forensic investigation (~$50k+)
        - Potential card network fines ($100k+)
        - Stripe account suspension
      code_examples:
        - # Python (compliant)
          compliant: |
            import stripe
            stripe.api_key = "sk_test_..."

            # SAFE: Using tokenized reference
            intent = stripe.PaymentIntent.create(
                amount=1000,
                currency='usd',
                payment_method='pm_1EXAMPLE',
                description='Order #123'
            )

            # SAFE: Displaying last 4 digits only
            print(f"Card used: **** **** **** {intent.charges.data[0].payment_method_details.card.last4}")

        - # JavaScript (non-compliant)
          non_compliant: |
            // UNSAFE: Raw data in logs
            logger.debug(`Processing card ${req.body.number}`);

            // UNSAFE: Temporary caching
            redis.set(`user:${userId}:card`, JSON.stringify({
              number: '4242424242424242',
              exp: '12/25',
              cvv: '123'
            }));

            // UNSAFE: Database "backup"
            db.query(`
              INSERT INTO failed_payments 
              VALUES (${req.body.number}, ${req.body.cvv})
            `);

        - # Python (non-compliant)
          non_compliant: |
            # UNSAFE: Writing card data to a file or log
            with open("card_log.txt", "a") as f:
                f.write(f"{request.POST['card_number']} {request.POST['cvv']}\n")  # PCI violation

    - title: "Require Access Control for Tokenized Payment Data Endpoints"
      severity: High
      required_context: Backend services handling payment tokens
      software_version: all
      reference_link:
        - https://docs.stripe.com/security/guide#least-privilege
        - https://stripe.com/legal/ssa#section_d
      description: |
        All backend endpoints or functions that access tokenized payment data (PaymentMethods, Tokens, PaymentIntents) must implement explicit access control checks in code, such as decorators, middleware, or permission checks.
      impact: |
        Lack of access control can result in unauthorized access to tokenized payment data, increasing the risk of data breaches and regulatory penalties.
      code_examples:
        - # Python (compliant)
          compliant: |
            # Example: Django middleware enforcing access control
            def payment_access_required(view_func):
                def _wrapped_view(request, *args, **kwargs):
                    user = request.user
                    if not user.has_perm("payments.view_payment_method"):
                        log_unauthorized_access(user.id, "payment_method")
                        return JsonResponse({"error": "Forbidden"}, status=403)
                    return view_func(request, *args, **kwargs)
                return _wrapped_view

            @payment_access_required
            def get_payment_method(request, id):
                method = PaymentMethod.objects.get(id=id)
                return JsonResponse({"last4": method.last4})

        - # Node.js (compliant)
          compliant: |
            // Middleware with attribute-based checks
            const paymentAccessControl = (resourceType) => {
              return async (req, res, next) => {
                const user = await getUserPermissions(req.user.id);
                if (user.roles.includes('payment_processor')) {
                  return next();
                }
                return res.status(403).json({ 
                  error: 'Forbidden: Insufficient payment access rights' 
                });
              };
            };

            // Protected route
            router.get(
              '/v1/payment_methods/:id',
              paymentAccessControl('payment_method'),
              getPaymentMethodHandler
            );

        - # JavaScript (non-compliant)
          non_compliant: |
            // UNSAFE: No access control on sensitive endpoint
            app.get('/api/payments/:userId', async (req, res) => {
              const userId = req.params.userId;

              // ✅ Uses parameterized query to avoid SQL injection
              // ❌ Still missing access control
              const payments = await db.query(
                'SELECT * FROM payment_methods WHERE user_id = $1',
                [userId]
              );

              res.json(payments); // ❌ Exposes sensitive tokenized data to any caller
            });


        - # JSON (IAM policy — non-compliant)
          non_compliant: |
            // UNSAFE: Over-permissive AWS IAM policy
            {
              "Effect": "Allow",
              "Action": ["dynamodb:GetItem"],
              "Resource": "arn:aws:dynamodb:*:*:table/PaymentMethods"
            }

    - title: "Enforce SAQ-A Eligible Payment Architecture"
      severity: Critical
      required_context: Payment system architecture design
      software_version: all
      reference_link:
        - https://stripe.com/docs/security/guide#pci-compliance
        - https://www.pcisecuritystandards.org/documents/PCI-DSS-v4_0-SAQ-A.pdf
      description: |
        Payment systems must exclusively use Stripe-hosted payment solutions — such as Stripe Checkout and the Payment Element.
      impact: |
        Compliance benefits:
        - Qualifies for SAQ-A (22 controls) vs SAQ-D (330+ controls)
        - Eliminates $50k+ annual audit costs
        - Reduces breach reporting obligations

        Violation consequences:
        - Immediate reclassification to SAQ-D
        - Mandatory quarterly ASV scans
        - Potential card network fines
      code_examples:
        - # JavaScript — compliant
          compliant: |
            // COMPLIANT: Stripe-hosted Checkout
            stripe.redirectToCheckout({
              lineItems: [{ price: 'price_1EXAMPLE', quantity: 1 }],
              mode: 'payment',
              successUrl: 'https://example.com/success',
              cancelUrl: 'https://example.com/cancel'
            });

            // COMPLIANT: Embedded Payment Element
            const elements = stripe.elements({
              mode: 'payment',
              amount: 1099,
              currency: 'usd'
            });
            const paymentElement = elements.create('payment');
            paymentElement.mount('#payment-element');

        - # HTML + JS — non-compliant
          non_compliant: |
            <!-- VIOLATION: Custom payment form with raw input -->
            <form action="/process_payment" method="POST">
              <input type="text" name="card_number" placeholder="Card number">
              <input type="text" name="expiry" placeholder="MM/YY">
              <input type="text" name="cvc" placeholder="CVC">
              <button type="submit">Pay</button>
            </form>

        - # Node.js — non-compliant
          non_compliant: |
            // VIOLATION: Proxy server handling card data
            app.post('/proxy_payment', (req, res) => {
              const payload = {
                number: req.body.card_number,  // CHD exposure
                cvc: req.body.cvc
              };
              stripe.tokens.create({ card: payload });  // Still violates SAQ-A
            });

        - # Python (illustrative non-compliance)
          non_compliant: |
            # VIOLATION: Django view accepting card data directly
            @csrf_exempt
            def handle_card_post(request):
                if request.method == "POST":
                    card_number = request.POST["card_number"]
                    cvc = request.POST["cvc"]
                    # Dangerous: CHD flowing through Django server
                    stripe.Token.create(
                        card={
                            "number": card_number,
                            "cvc": cvc,
                            "exp_month": 12,
                            "exp_year": 2025
                        }
                    )
                    return JsonResponse({"status": "CHD violation"})

    - title: "Prohibit Custom Card Data Input Fields"
      severity: Critical
      required_context: Client-side payment form implementation
      software_version: all
      reference_link:
        - https://stripe.com/docs/security/guide#secure-payment-input
        - https://stripe.com/docs/stripe-js/elements
        - https://www.pcisecuritystandards.org/documents/PCI-DSS-v4_0-SAQ-A.pdf
      description: |
        Card data collection must exclusively use:
        - Stripe Elements (CardElement, PaymentElement)
        - Stripe Checkout (hosted or embedded)
        - Stripe Terminal SDK for hardware payments

        Strictly prohibited:
        - Custom <input> elements for PAN/CVV/expiry
        - JavaScript handlers for raw card data
        - Form submissions containing card details
        - Modifications to Stripe-controlled iframes
      impact: |
        Compliance benefits:
        - Maintains SAQ-A eligibility (22 controls vs 330+ for SAQ-D)
        - Eliminates $50k+ annual PCI audit costs
        - Removes requirement for quarterly ASV scans

        Violation consequences:
        - Immediate PCI scope expansion to SAQ-D
        - Mandatory forensic investigation if breached
        - Stripe account review/freeze
      code_examples:
        - # JavaScript — compliant
          compliant: |
            // COMPLIANT: Payment Element (recommended)
            const paymentElement = elements.create('payment', {
              fields: {
                billingDetails: {
                  email: 'never'  // Disables email collection in iframe
                }
              }
            });
            paymentElement.mount('#payment-element');

            // COMPLIANT: Legacy Card Element with full integration
            const cardElement = elements.create('card', {
              style: {
                base: {
                  fontSize: '16px',
                  color: '#32325d'
                }
              }
            });
            cardElement.mount('#card-element');

            const form = document.getElementById('payment-form');
            form.addEventListener('submit', async (event) => {
              event.preventDefault();
              const { error, paymentMethod } = await stripe.createPaymentMethod({
                type: 'card',
                card: cardElement,
              });

              if (error) {
                console.error(error);
              } else {
                console.log('PaymentMethod created:', paymentMethod.id);
                // Submit paymentMethod.id to your backend here
              }
            });

        - # HTML/JS — non-compliant
          non_compliant: |
            <!-- VIOLATION: Custom card form fields -->
            <form id="payment-form">
              <input type="text" id="card-number" placeholder="Card number">
              <input type="text" id="card-expiry" placeholder="MM/YY">
              <input type="text" id="card-cvc" placeholder="CVC">
              <button>Submit</button>
            </form>

            // VIOLATION: Attempting to extract card number from Stripe Element
            const cardElement = elements.create('card');
            cardElement.mount('#card-element');

            // UNSAFE: Trying to directly access sensitive card info
            const rawCardNumber = document.querySelector('#card-element iframe').contentWindow.document.querySelector('input[name="cardnumber"]');
            console.log('Extracted card number:', rawCardNumber?.value);  // This is prohibited

        - # Python (Django) — non-compliant
          non_compliant: |
            # VIOLATION: Raw card fields posted to server
            @csrf_exempt
            def collect_card_input(request):
                if request.method == "POST":
                    pan = request.POST.get("card_number")
                    exp = request.POST.get("card_expiry")
                    cvc = request.POST.get("card_cvc")
                    # CHD exposure — violates PCI scope boundaries
                    logger.warning("Raw card data received: %s", pan)
                    return JsonResponse({"status": "unsafe"})

    - title: "Enforce TLS 1.2+ Encryption for All Payment Communications"
      severity: Critical
      required_context: All network communications involving payment data
      software_version: all
      reference_link:
        - https://stripe.com/docs/security/guide#https-and-tls
        - https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security
        - https://docs.nginx.com/nginx/admin-guide/security-controls/securing-http-traffic-upstream/#enabling-tls-1-3
        - https://www.pcisecuritystandards.org/documents/PCI_DSS_v4-0.pdf
      description: |
        Application code must explicitly configure TLS version 1.2 or higher for all outgoing HTTPS requests transmitting payment data.
      impact: |
        Compliance benefits:
        - Satisfies PCI DSS Requirement 4.1
        - Prevents 85% of MITM attack vectors
        - Qualifies for SAQ A-EP reduced scope

        Violation consequences:
        - Immediate PCI non-compliance
        - Stripe API request rejection (HTTP 426)
        - Browser warnings for customers
      code_examples:
        - compliant: |
            # Python: Enforcing TLS 1.2+ using requests with SSLContext
            import requests
            import ssl
            from urllib3.poolmanager import PoolManager
            from requests.adapters import HTTPAdapter

            class TLSAdapter(HTTPAdapter):
                def init_poolmanager(self, *args, **kwargs):
                    ctx = ssl.create_default_context()
                    ctx.minimum_version = ssl.TLSVersion.TLSv1_2
                    ctx.maximum_version = ssl.TLSVersion.TLSv1_3
                    kwargs['ssl_context'] = ctx
                    return super().init_poolmanager(*args, **kwargs)

            session = requests.Session()
            session.mount("https://", TLSAdapter())

            response = session.post(
                "https://api.stripe.com/v1/payment_intents",
                headers={"Authorization": "Bearer sk_test_..."},
                data={"amount": 1000, "currency": "usd"}
            )

            # Nginx config for TLS 1.3
            ssl_protocols TLSv1.2 TLSv1.3;
            ssl_prefer_server_ciphers on;
            ssl_ciphers "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:ECDHE-ECDSA-AES256-GCM-SHA384";
            add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

        - non_compliant: |
            # Node.js: UNSAFE configuration allowing deprecated TLS
            const https = require('https');
            const agent = new https.Agent({
              maxVersion: 'TLSv1.1'  // VIOLATION
            });

            // Stripe API call with deprecated security
            fetch('https://api.stripe.com/v1/customers', {
              method: 'GET',
              agent
            });

            # Nginx: Weak and insecure cipher configuration
            ssl_protocols SSLv3 TLSv1 TLSv1.1;
            ssl_ciphers "RC4-SHA:DES-CBC3-SHA";

    - title: "Implement Code-Level PCI Controls for Stripe Integration"
      severity: High
      required_context: PCI Compliance Program Management
      software_version: all
      reference_link:
        - https://stripe.com/docs/security/guide#pci-compliance
        - https://www.pcisecuritystandards.org/documents/PCI-DSS-v4_0.pdf
        - https://stripe.com/docs/security/guide#pci-checklist
      description: |
        Source code must implement Stripe PCI compliance controls that can be verified during code review, including:

        - Loading Stripe.js exclusively from https://js.stripe.com/v3/
        - Ensuring no cardholder data (CHD) is captured in variables or log statements
        - Enforcing TLS 1.2+ for outbound HTTPS requests initiated in application code
      impact: |
        These code-level controls reduce PCI DSS scope and maintain SAQ-A eligibility.

        Failure to implement these controls may:
        - Invalidate audit readiness during static analysis
        - Trigger Stripe compliance flags
        - Increase scope during incident forensics

      code_examples:
        - # Python (compliant)
          compliant: |
            import logging
            import ssl
            import urllib.request

            # Ensure logging does not capture CHD
            logging.info("Payment request initiated.")  # No card data here

            # Enforce TLS 1.2+ in outbound request
            context = ssl.create_default_context()
            context.minimum_version = ssl.TLSVersion.TLSv1_2
            urllib.request.urlopen("https://api.stripe.com", context=context)

        - # Django Template (compliant)
          compliant: |
            <!-- Load Stripe.js securely -->
            <script src="https://js.stripe.com/v3/"></script>

        - # Python (non-compliant)
          non_compliant: |
            card_number = "4242 4242 4242 4242"
            logging.info(f"Card used: {card_number}")  # CHD exposed in logs

            # No TLS version set – insecure default may apply
            urllib.request.urlopen("https://api.stripe.com")

        - # Django Template (non-compliant)
          non_compliant: |
            <!-- Insecure CDN for Stripe.js -->
            <script src="https://cdn.example.com/stripe.js"></script>

    - title: "Require Webhook Signature Verification for Payment Processing"
      severity: High
      required_context: Backend payment event processing
      software_version: all
      reference_link:
        - https://stripe.com/docs/webhooks
        - https://stripe.com/docs/security/guide#webhooks
        - https://stripe.com/docs/checkout/fulfill-orders
      description: |
        All backend webhook endpoints processing Stripe payment events must verify webhook signatures using the Stripe-Signature header.
      impact: |
        Failure to verify webhook signatures can result in unauthorized or spoofed payment events, leading to fraud and loss of PCI compliance.
      code_examples:
        - # Python (Django) — COMPLIANT: Verified webhook processing with signature validation
          compliant: |
            import stripe
            from django.http import HttpResponse, HttpResponseBadRequest
            from django.views.decorators.csrf import csrf_exempt
            from django.views.decorators.http import require_POST
            import os

            stripe.api_key = os.getenv("STRIPE_SECRET_KEY")
            endpoint_secret = os.getenv("STRIPE_WEBHOOK_SECRET")

            @csrf_exempt
            @require_POST
            def stripe_webhook(request):
                payload = request.body
                sig_header = request.META.get("HTTP_STRIPE_SIGNATURE")

                try:
                    event = stripe.Webhook.construct_event(
                        payload, sig_header, endpoint_secret
                    )
                except ValueError:
                    return HttpResponseBadRequest()  # Invalid payload
                except stripe.error.SignatureVerificationError:
                    return HttpResponseBadRequest()  # Invalid signature

                # ...handle event...
                return HttpResponse(status=200)

        - # Python (Flask) — NON-COMPLIANT: Missing signature verification
          non_compliant: |
            from flask import Flask, request
            import stripe

            app = Flask(__name__)
            stripe.api_key = "sk_test_..."

            @app.route('/webhook', methods=['POST'])
            def unsafe_webhook():
                # No signature check — vulnerable to spoofing
                event = request.get_json()
                fulfill_order(event["data"]["object"])
                return '', 200

    - title: "Avoid Hardcoded Cardholder Data Patterns in Source Code"
      severity: Critical
      required_context: All source files handling user input or payment logic
      software_version: all
      reference_link:
        - https://stripe.com/docs/security/guide#card-data
        - https://www.pcisecuritystandards.org/documents/PCI-DSS-v4_0.pdf
      description: |
        Source code must not contain hardcoded Primary Account Numbers (PANs, 15–16 digit numbers) or CVV/CVC values (3–4 digits).
      impact: |
        Compliance benefits:
        - Reduces accidental storage of CHD in source repos
        - Supports PCI DSS Requirements 3.2 and 3.3
        - Minimizes risk of public code leaks containing PAN/CVV

        Violations may result in:
        - Stripe account deactivation
        - PCI breach disclosure obligations
        - Card network fines

      code_examples:
        # Python — COMPLIANT: Uses masked token instead of hardcoded PAN
        - compliant: |
            def charge_customer(payment_method_id):
                if not payment_method_id.startswith("pm_"):
                    raise ValueError("Invalid token format")
                # Proceed with tokenized payment
                process_token(payment_method_id)

        # JavaScript — NON-COMPLIANT: Hardcoded PAN and CVV
        - non_compliant: |
            // VIOLATION: PAN and CVV stored in source
            const testCard = {
              number: "4242424242424242",
              cvv: "123"
            };

  - name: "Idempotency Keys & Safe Retries"
    paths:
      - '**/payments/**'
      - '**/charges/**'
      - '**/subscriptions/**'
      - '**/webhooks/**'
      - '**/*.js'
      - '**/*.ts'
      - '**/*.py'
      - '**/*.rb'
    policies:
    - title: "Include Idempotency Key in Stripe Write Requests"
      description: |
        Include an `Idempotency-Key` header in all Stripe write requests.
      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Stripe API Write Operations
      severity: High
      impact: |
        - Prevents duplicate charges or refunds
        - Enables safe retry of failed requests
        - Improves observability and debugging
      code_examples:
        # language: python
        - compliant: |
            import uuid
            import requests

            idempotency_key = str(uuid.uuid4())

            headers = {
                "Authorization": "Bearer sk_test_...",
                "Idempotency-Key": idempotency_key
            }

            response = requests.post(
                "https://api.stripe.com/v1/charges",
                headers=headers,
                data={
                    "amount": 1000,
                    "currency": "usd",
                    "source": "tok_visa",
                    "description": "Charge for order #1234"
                }
            )
        - non_compliant: |
            response = requests.post(
                "https://api.stripe.com/v1/charges",
                headers={
                    "Authorization": "Bearer sk_test_..."
                },
                data={
                    "amount": 1000,
                    "currency": "usd",
                    "source": "tok_visa"
                }
            )

    - title: "Standardize Idempotency Key Generation"
      severity: High
      required_context: Backend payment processing
      software_version: all
      reference_link:
        - https://stripe.com/docs/idempotency
      description: |
        Idempotency keys must be generated using:
        1. A unique user or session identifier
        2. The action being performed (e.g., "createPayment", "refund")
        3. A millisecond-resolution timestamp
        4. A cryptographically secure random suffix
        5. (Optional) version marker for business logic changes

        Recommended format:
        `<userId>-<action>-<timestamp>-<random_suffix>`
      impact: |
        - Prevents accidental duplicates during retries
        - Ensures auditability of operations
        - Maintains backward compatibility across deployment versions
      code_examples:
        # Python — COMPLIANT: Secure, unique, and timestamped idempotency key
        - compliant: |
            import time
            import secrets

            def generate_idempotency_key(user_id, action):
                timestamp = int(time.time() * 1000)
                random_suffix = secrets.token_hex(4)
                return f"{user_id}-{action}-{timestamp}-{random_suffix}"

            key = generate_idempotency_key("user_789", "createPayment")
            stripe.PaymentIntent.create(
                amount=1000,
                currency='usd',
                payment_method='pm_123',
                idempotency_key=key
            )

        # JavaScript — NON-COMPLIANT: Predictable and collision-prone idempotency key
        - non_compliant: |
            let counter = 0;
            function getKey() {
                return `key-${++counter}`; // Predictable keys are not safe
            }

            stripe.refunds.create({
              payment_intent: 'pi_123',
              amount: 500
            }, {
              idempotencyKey: getKey()
            });

    - title: "Enforce Idempotency Key Expiration Policies"
      severity: High
      required_context: Backend payment processing systems
      software_version: all
      reference_link:
        - https://stripe.com/docs/idempotency
      description: |
        All idempotency key storage must implement a TTL (time-to-live) no longer than 72 hours, with a 24-hour duration preferred.
      impact: |
        Avoids stale keys leading to unintended retries, prevents cache bloating,
        and enforces consistency across payment attempts.
      code_examples:
        # JavaScript (Node.js + Redis) — COMPLIANT: TTL + purge with cron cleanup
        - compliant: |
            const setWithExpiry = async (key, data) => {
              await redis.multi()
                .set(`idemp:${key}`, JSON.stringify(data))
                .expire(`idemp:${key}`, 24 * 60 * 60)
                .exec();
            };

        # Python (Redis + TTL) — COMPLIANT: Expiring idempotency key with TTL and logging
        - compliant: |
            import redis
            import json
            import time

            r = redis.StrictRedis(host='localhost', port=6379, db=0)

            def store_idempotency_key(key, data, ttl_seconds=86400):
                namespaced_key = f"idemp:{key}"
                r.setex(namespaced_key, ttl_seconds, json.dumps(data))

            store_idempotency_key("user123-createPayment-...", {"status": "processing"})

        # SQL — NON-COMPLIANT: No TTL enforcement or automated expiry logic
                # SQL — NON-COMPLIANT: Keys stored without TTL enforcement
        - non_compliant: |
            await db.query("""
              INSERT INTO idempotency_keys (key, data, created_at)
              VALUES ($1, $2, NOW())
            """, [key, data]);
            
            // No background job or TTL column used to expire keys

    - title: "Enforce Idempotency Keys for Payment Operations"
      severity: High
      required_context: Backend API integrations
      software_version: all
      reference_link:
        - https://stripe.com/docs/api/idempotent_requests
      description: >
        All POST requests that mutate payment state must use unique, predictable, and persistent idempotency keys to prevent duplicate operations.
      impact: >
        Prevents accidental duplicate charges or subscriptions during retries or network errors.
      code_examples:
        # JavaScript — COMPLIANT: Idempotency key used
        - compliant: |
            stripe.charges.create({
              amount: 2000,
              currency: 'usd',
              source: 'tok_visa'
            }, {
              idempotencyKey: 'unique_key_12345' // Ensure uniqueness and persistence
            });

        # JavaScript — NON-COMPLIANT: No idempotency key used
        - non_compliant: |
            stripe.charges.create({
              amount: 2000,
              currency: 'usd',
              source: 'tok_visa'
            }); // May result in duplicate charge if retried

    - title: "Implement Safe Retry Logic for Payment Operations"
      severity: High
      required_context: Backend API integrations
      software_version: all
      reference_link:
        - https://stripe.com/docs/error-handling#network-retries
      description: >
        Retry logic for payment APIs must only retry on transient errors, avoid unsafe retries, and use capped exponential backoff with jitter.
      impact: >
        Ensures resilience to transient errors without violating payment integrity or causing API abuse.
      code_examples:
        # Python — COMPLIANT: Safe retry with backoff and error filtering
        - compliant: |
            def with_retry(fn, max_attempts=3):
                ...
                # logic from earlier

        # JavaScript — NON-COMPLIANT: Retries all errors, no backoff, unsafe
        - non_compliant: |
            const retry = async (fn, retries = 5) => {
              for (let i = 0; i < retries; i++) {
                try {
                  return await fn();
                } catch (err) {
                  await new Promise(r => setTimeout(r, 1000)); // Fixed delay, no filtering
                }
              }
            };

    - title: "Scope of Idempotency"
      severity: Medium
      required_context: API Design / Payment Operations
      software_version: all
      reference_link:
        - https://stripe.com/docs/idempotency
      description: |
        Apply idempotency only to API operations that cause side effects (e.g., creating payments, updating subscriptions, processing refunds), and exclude it from read-only operations.
      impact: |
        - Prevents duplicate financial actions due to client/network retries.
        - Simplifies handling for read-only endpoints.
        - Enables safe retries across microservices and external integrators.
      code_examples:
        # JavaScript — COMPLIANT: Idempotency key applied correctly to POST with side effects
        - compliant: |
            // Idempotency for a POST payment request
            fetch("/charge", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "Idempotency-Key": "user-1234-charge-20250726"
              },
              body: JSON.stringify({ amount: 5000, currency: "usd" })
            });

        # JavaScript — NON-COMPLIANT: Idempotency applied unnecessarily to GET request
        - non_compliant: |
            // Unnecessary idempotency on a GET request
            fetch("/user-profile", {
              method: "GET",
              headers: {
                "Idempotency-Key": "read-profile-key"
              }
            });

    - title: "Logging of Idempotent Requests"
      severity: Medium
      required_context: Observability / Backend Resilience
      software_version: all
      reference_link:
        - https://stripe.com/docs/idempotency#observability
      description: |
        All idempotent requests must be logged with the following:
        - The received `Idempotency-Key`
        - The API endpoint and action performed
        - The final status (success, failure, retry)
        - A timestamp
      impact: |
        - Enables full audit trails for sensitive payment actions
        - Provides visibility into idempotent usage patterns
        - Supports detection of retry-related anomalies through logs
      code_examples:
        # JavaScript — COMPLIANT: Proper logging for idempotent requests
        - compliant: |
            // Server-side logging
            logger.info({
              idempotency_key: req.headers["Idempotency-Key"],
              endpoint: req.path,
              status: "success",
              timestamp: new Date().toISOString()
            });

        # JavaScript — NON-COMPLIANT: Logging exists but misses required idempotency fields
        - non_compliant: |
            // Incomplete logging for an idempotent request
            logger.info({
              message: "Payment processed",
              user_id: req.user.id,
              // Missing: idempotency_key, endpoint, status, timestamp
            });

    - title: "Key Collision & Conflict Resolution Policy"
      severity: High
      required_context: Backend Idempotency Handling
      software_version: all
      reference_link:
        - https://stripe.com/docs/idempotency#handling-conflicts
      description: |
        Systems must detect and reject idempotency key reuse when the request payload differs from the original.
      impact: |
        - Prevents inconsistent state caused by conflicting retry payloads
        - Ensures deterministic and predictable backend behavior
        - Blocks malicious or accidental misuse of shared keys
        - Rejections should use a `409 Conflict` (or equivalent) and avoid side effects
      code_examples:
        # JavaScript — COMPLIANT: Rejects mismatched retries and preserves original outcome
        - compliant: |
            const storedRequest = getStoredRequest(idempotencyKey);
            if (storedRequest && !deepEqual(storedRequest.payload, currentPayload)) {
              return res.status(409).json({ error: "Conflicting idempotent request." });
            }

            // No conflict – safe to proceed
            storeRequest(idempotencyKey, currentPayload);
            processTransaction(currentPayload);

        # JavaScript — NON-COMPLIANT: Allows conflicting payload reuse and unsafe retries
        - non_compliant: |
            // No conflict validation – may result in duplicate processing
            storeRequest(idempotencyKey, req.body);
            processTransaction(req.body);  // risk of inconsistent outcomes

    - title: "Client Responsibilities for Idempotency"
      severity: Medium
      required_context: API Client Integration
      software_version: all
      reference_link:
        - https://stripe.com/docs/idempotency#usage-on-the-client
      description: |
        Clients must ensure a single, unique idempotency key is generated per logical operation and consistently reused across retries of that same operation.
      impact: |
        - Prevents accidental duplicate charges or actions during retry scenarios
        - Allows backend idempotency protections to function correctly
        - Improves reliability of financial and sensitive operations
      code_examples:
        # JavaScript — COMPLIANT: Reuses the same key across retries
        - compliant: |
            // Generate the key once per logical operation
            const idempotencyKey = generateIdempotencyKey();

            async function chargeWithRetry(payload) {
              for (let attempt = 0; attempt < 3; attempt++) {
                try {
                  return await axios.post("/api/charge", payload, {
                    headers: { "Idempotency-Key": idempotencyKey }
                  });
                } catch (err) {
                  if (attempt === 2) throw err;
                }
              }
            }

        # JavaScript — NON-COMPLIANT: Regenerates new key on each retry attempt
        - non_compliant: |
            // Generates a new key on every retry — unsafe!
            async function chargeWithRetry(payload) {
              for (let attempt = 0; attempt < 3; attempt++) {
                try {
                  return await axios.post("/api/charge", payload, {
                    headers: { "Idempotency-Key": generateIdempotencyKey() }
                  });
                } catch (err) {
                  if (attempt === 2) throw err;
                }
              }
            }

            // Problem: Each retry sends a different key, defeating deduplication.

    - title: "Security and Privacy Considerations for Idempotency Keys"
      severity: High
      required_context: API Security & Gateway Configuration
      software_version: all
      reference_link:
        - https://stripe.com/docs/idempotency#safety
      description: |
        Idempotency keys **must never** contain:
        - Personally Identifiable Information (PII)
        - Internal or sequential user/account IDs
        - Emails, names, or session tokens
      impact: |
        - Prevents data leakage through logs or headers
        - Mitigates injection attacks via crafted key inputs
        - Ensures alignment with security and privacy compliance (e.g., GDPR, PCI)
      code_examples:
        # JavaScript — COMPLIANT: Uses opaque UUID as the idempotency key
        - compliant: |
            // Secure, opaque UUID-based key
            const idempotencyKey = "a3f9f7f0-8a2b-42d3-a1df-c16f2d83a2e1";

            axios.post("/api/order", payload, {
              headers: { "Idempotency-Key": idempotencyKey }
            });

        # JavaScript — NON-COMPLIANT: Key includes PII and internal identifiers
        - non_compliant: |
            // Embedding PII and internal identifiers — insecure
            const idempotencyKey = "user123-email@example.com-1627489200";

            axios.post("/api/order", payload, {
              headers: { "Idempotency-Key": idempotencyKey }
            });

    - title: "Safe Idempotent Retry Behavior"
      severity: Medium
      required_context: Backend Retry Logic
      software_version: all
      reference_link:
        - https://stripe.com/docs/idempotency#handling-errors
      description: |
        Backend logic must be implemented such that repeated requests with the same idempotency key do not result in duplicated side effects, even in cases of network failures or delayed retries.
      impact: |
        - Prevents silent regressions in idempotency logic
        - Ensures financial safety and backend consistency
        - Provides confidence during feature rollouts and refactors
      code_examples:
        # JavaScript — COMPLIANT: Verifies idempotency with stored outcomes
        - compliant: |
            const prior = getStoredOutcome(idempotencyKey);
            if (prior) return res.status(200).json(prior);

            const result = await createCharge(payload);
            storeOutcome(idempotencyKey, result);
            res.status(200).json(result);

        # JavaScript — NON-COMPLIANT: Lacks deduplication check
        - non_compliant: |
            // Missing idempotency check – may create multiple charges
            const result = await createCharge(payload);
            res.status(200).json(result);

    - title: "Enforce Structured Idempotency Key Format in API Requests"
      severity: Low
      required_context: Developer Onboarding & Integration
      software_version: all
      reference_link:
        - https://stripe.com/docs/idempotency
      description: |
        All API requests that mutate state must include a structured idempotency key in a predictable format.

        Recommended key structure:
        - `<userId>-<actionType>-<timestamp>-<version>`

        Example: `12345-createOrder-1698870000-v1`

        Keys must be:
        - Deterministically generated per logical operation
        - Unique but reproducible for retries of the same operation
        - Consistently scoped and versioned
      impact: |
        - Promotes correct usage of idempotency keys without relying on subjective documentation
        - Enables verification via static code rules or log auditing
        - Reduces risk of duplicate operations due to inconsistent key formats
      code_examples:
        # JavaScript — COMPLIANT: Structured and consistent idempotency key
        - compliant: |
            // Structured key format: userId-actionType-timestamp-version
            const userId = "12345";
            const action = "createOrder";
            const timestamp = Date.now();
            const version = "v1";

            const key = `${userId}-${action}-${timestamp}-${version}`;

            await axios.post("/api/orders", payload, {
              headers: { "Idempotency-Key": key }
            });

        # JavaScript — NON-COMPLIANT: Unstructured, random key generation
        - non_compliant: |
            // Unstructured, non-deterministic key
            const key = Math.random().toString(); // Risk of duplication or collision

            await axios.post("/api/orders", payload, {
              headers: { "Idempotency-Key": key }
            });

  - name: "Webhook Handling & Verification"
    paths:
      - "**/webhooks/**"
      - "**/handlers/webhook*.js"
      - "**/handlers/webhook*.ts"
      - "**/routes/webhook*.py"
      - "**/controllers/webhook*.rb"
      - "**/api/webhook*"
    policies:
    - title: "Signature Validation Policy for Webhooks"
      severity: High
      required_context: Webhook Handling
      software_version: all
      reference_link:
        - https://stripe.com/docs/webhooks/signatures
      description: |
        Incoming Stripe webhook requests must be validated using the configured signing secret before any payload is processed. Requests lacking a valid `stripe-signature` header must be rejected.
      impact: |
        - Prevents spoofed or forged webhook requests
        - Ensures only authentic Stripe events reach your backend
        - Supports PCI-DSS and Stripe integration security compliance
      code_examples:
        # JavaScript (Express + Stripe) — COMPLIANT: Proper webhook signature validation
        - compliant: |
            const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);
            const endpointSecret = process.env.STRIPE_WEBHOOK_SECRET;

            app.post('/webhook', express.raw({ type: 'application/json' }), (req, res) => {
              const sig = req.headers['stripe-signature'];
              let event;

              try {
                event = stripe.webhooks.constructEvent(req.body, sig, endpointSecret);
              } catch (err) {
                console.error("Webhook signature verification failed.", err.message);
                return res.sendStatus(400);
              }

              // Validated event
              res.sendStatus(200);
            });

        # JavaScript — NON-COMPLIANT: No signature verification at all
        - non_compliant: |
            // No verification — unsafe webhook handling
            app.post('/webhook', (req, res) => {
              const event = req.body;
              // Lacks signature check — allows forged payloads
              res.sendStatus(200);
            });

    - title: "Minimal Synchronous Processing"
      severity: Medium
      required_context: Webhook Handler Logic
      software_version: all
      reference_link:
        - https://stripe.com/docs/webhooks/best-practices
      description: |
        Webhook handlers must perform **only essential logic synchronously**, including:
        - Signature verification
        - Basic schema validation or authentication
        - Immediate queuing of the event (e.g., via message broker or job queue)

        All long-running operations—such as DB writes, third-party API calls, or business workflows—
        **must be offloaded** to asynchronous workers or background jobs.
      impact: |
        - Prevents Stripe timeouts and reduces the chance of duplicate delivery
        - Ensures reliable processing under load
        - Improves system responsiveness and avoids blocking I/O in the request lifecycle
      code_examples:
        # JavaScript (Express) — COMPLIANT: Only minimal logic in sync handler
        - compliant: |
            app.post("/webhook", (req, res) => {
              const event = req.body;

              // Minimal synchronous logic
              if (!verifySignature(req)) {
                return res.sendStatus(403);
              }

              // Enqueue for async processing
              queueEvent(event);

              res.sendStatus(200);
            });

        # JavaScript — NON-COMPLIANT: Contains blocking business logic in sync handler
        - non_compliant: |
            // Anti-pattern: synchronous business logic in webhook handler
            app.post("/webhook", async (req, res) => {
              const event = req.body;

              // Blocking DB operation — risks timeouts
              await updateDatabase(event);

              res.sendStatus(200);
            });

    - title: "Asynchronous Job Queuing"
      severity: High
      required_context: Webhook Event Architecture
      software_version: all
      reference_link:
        - https://stripe.com/docs/webhooks/best-practices
      description: |
        Webhook handlers must immediately enqueue all received events into a **durable job queue** (e.g., Kafka, AWS SQS, RabbitMQ, Sidekiq), including relevant metadata such as:
        - `event.id`
        - `event.type`
        - `timestamp` or `received_at`

        Inline or synchronous processing of the event body must be avoided.
      impact: |
        - Guarantees delivery and retry safety even under load
        - Prevents failures due to network issues or upstream system delays
        - Enables horizontal scaling of event consumers and better observability/debugging
      code_examples:
        # JavaScript (Express) — COMPLIANT: Immediately enqueues event to job queue
        - compliant: |
            app.post("/webhook", (req, res) => {
              const event = req.body;

              // Construct traceable metadata
              const metadata = {
                type: event.type,
                id: event.id,
                received_at: Date.now()
              };

              // Push to queue for async processing
              enqueueJob("stripe-events", { event, metadata });

              res.sendStatus(200);
            });

        # JavaScript — NON-COMPLIANT: Inline processing with no queuing or metadata
        - non_compliant: |
            // Risky: processes event inline, lacks fault tolerance
            app.post("/webhook", (req, res) => {
              const event = req.body;

              // May cause retry storms or delayed acknowledgments
              processEvent(event);

              res.sendStatus(200);
            });

    - title: "Fast Acknowledgment Response"
      severity: High
      required_context: Webhook Acknowledgment Handling
      software_version: all
      reference_link:
        - https://stripe.com/docs/webhooks/best-practices
      description: |
        Webhook handlers must respond with a 2xx status code (e.g., 200 OK) immediately after performing lightweight checks such as signature validation or queuing. The response must not be delayed by business logic, database writes, or external API calls.
      impact: |
        - Prevents unnecessary webhook retries from Stripe
        - Reduces load and duplicate processing on backend systems
        - Improves API responsiveness and user trust
        - Enables better scaling under high event throughput
      code_examples:
        # JavaScript (Express) — COMPLIANT: Sends 200 OK immediately after validation and queueing
        - compliant: |
            app.post("/webhook", (req, res) => {
              const event = req.body;

              // Minimal validation
              if (!isValidSignature(req)) return res.sendStatus(400);

              // Queue and acknowledge
              enqueueJob("webhook-events", event);
              res.sendStatus(200);
            });

        # JavaScript — NON-COMPLIANT: Acknowledgment delayed by long-running async logic
        - non_compliant: |
            // Problem: response delayed by long-running logic
            app.post("/webhook", async (req, res) => {
              const event = req.body;

              if (!isValidSignature(req)) return res.sendStatus(400);

              // Risky: blocks Stripe acknowledgment
              await performBusinessLogic(event);

              res.sendStatus(200);
            });

    - title: "Duplicate Event Handling"
      severity: High
      required_context: Webhook Job Processing
      software_version: all
      reference_link:
        - https://stripe.com/docs/webhooks/best-practices#duplicate-events
      description: |
        Downstream processing logic must be idempotent and use the `event.id` field to ensure that each webhook event is handled only once.
      impact: |
        - Prevents double billing, double refunds, or duplicate record creation
        - Guarantees consistency in distributed and retry-prone systems
        - Protects against race conditions and replay attacks
      code_examples:
        # JavaScript — COMPLIANT: Checks for prior processing using event.id before executing logic
        - compliant: |
            async function handleWebhook(event) {
              // Check if event was already processed
              const alreadyProcessed = await db.eventLog.exists({ id: event.id });
              if (alreadyProcessed) return;

              // Record the event to prevent reprocessing
              await db.eventLog.insert({ id: event.id, processed_at: Date.now() });

              // Business logic executes only once
              processPayment(event.data.object);
            }

        # JavaScript — NON-COMPLIANT: Lacks any deduplication logic, allows duplicate processing
        - non_compliant: |
            async function handleWebhook(event) {
              // Unsafe: no deduplication check
              processPayment(event.data.object);
            }

    - title: "Structured Logging of Webhook Events"
      severity: Medium
      required_context: Webhook Endpoint
      software_version: all
      reference_link:
        - https://stripe.com/docs/webhooks/best-practices#logging
      description: |
        Webhook handlers must log Stripe event metadata using structured logging patterns. Logs should include:
        - The `event.id` and `event.type` fields from the payload
        - A timestamp (via `Date.now()` or `new Date().toISOString()`)
        - Result of signature verification logic
        - Request headers passed through a sanitization function
      impact: |
        - Ensures webhook events are traceable and debuggable
        - Improves incident response and observability
        - Enables static validation of logging logic in code
      code_examples:
        # JavaScript — COMPLIANT: Logs required fields with sanitization
        - compliant: |
            app.post("/webhook", (req, res) => {
              const signature = req.headers["stripe-signature"];
              const body = req.body;

              const isValid = verifySignature(body, signature);

              logger.info({
                event_type: body.type,
                event_id: body.id,
                signature_valid: isValid,
                headers: sanitize(req.headers),
                received_at: new Date().toISOString()
              });

              res.sendStatus(200);
            });

        # JavaScript — NON-COMPLIANT: Missing structured logging and signature status
        - non_compliant: |
            app.post("/webhook", (req, res) => {
              processEvent(req.body);
              res.sendStatus(200);
            });

    - title: "Webhook Metric Instrumentation"
      severity: Medium
      required_context: Webhook Infrastructure
      software_version: all
      reference_link:
        - https://stripe.com/docs/webhooks/best-practices#monitoring
      description: |
        Webhook handlers must include function calls that record delivery status, signature verification result, and response latency.
      impact: |
        - Encourages consistent observability patterns across codebases
        - Allows downstream monitoring and alerting systems to consume structured metrics
        - Supports static detection of metric instrumentation coverage
      code_examples:
        # JavaScript — COMPLIANT: Metrics recorded using internal helper
        - compliant: |
            app.post("/webhook", (req, res) => {
              const start = Date.now();
              const signature = req.headers["stripe-signature"];
              const isValid = verifySignature(req.body, signature);

              recordMetric("webhook_event", {
                type: req.body.type,
                signature_valid: isValid,
                latency_ms: Date.now() - start
              });

              res.sendStatus(200);
            });

        # JavaScript — NON-COMPLIANT: No metric collection functions used
        - non_compliant: |
            app.post("/webhook", (req, res) => {
              processEvent(req.body);
              res.sendStatus(200);
            });

    - title: "IP Allowlisting for Webhook Endpoints"
      severity: High
      required_context: Webhook Endpoint Security
      software_version: all
      reference_link:
        - https://stripe.com/docs/webhooks/best-practices#securing
      description: |
        Webhook endpoints must restrict incoming requests to known Stripe IP addresses using IP allowlisting.
      impact: |
        - Blocks unauthorized sources from accessing sensitive webhook endpoints
        - Reduces risk of spoofed or malicious traffic
      code_examples:
        # JavaScript — COMPLIANT: IP allowlisting middleware
        - compliant: |
            app.use("/webhook", (req, res, next) => {
              const allowedIPs = ["3.18.12.63", "3.130.192.231"]; // Example Stripe IPs
              if (!allowedIPs.includes(req.ip)) {
                return res.status(403).send("Forbidden - IP not allowed");
              }
              next();
            });

        # JavaScript — NON-COMPLIANT: No IP filtering
        - non_compliant: |
            app.post("/webhook", (req, res) => {
              handleWebhook(req.body); // No IP allowlist
              res.sendStatus(200);
            });

    - title: "Rate Limiting for Webhook Endpoints"
      severity: High
      required_context: Webhook Endpoint Security
      software_version: all
      reference_link:
        - https://stripe.com/docs/webhooks/best-practices#securing
      description: |
        Webhook endpoints must apply rate limiting.
      impact: |
        - Prevents resource exhaustion from high-volume traffic
        - Increases webhook reliability and server stability
      code_examples:
        # JavaScript — COMPLIANT: Uses rate limiting middleware
        - compliant: |
            app.use("/webhook", rateLimiter({
              max: 50,
              windowMs: 60 * 1000 // 50 requests per minute
            }));

        # JavaScript — NON-COMPLIANT: No rate limiting applied
        - non_compliant: |
            app.post("/webhook", (req, res) => {
              handleWebhook(req.body); // No rate limiter
              res.sendStatus(200);
            });

    - title: "User-Agent Validation for Stripe Webhook Endpoints"
      severity: High
      required_context: Webhook Endpoint Security
      software_version: all
      reference_link:
        - https://stripe.com/docs/webhooks/best-practices#securing
      description: |
        Stripe webhook endpoints must validate the User-Agent header to reject malformed or spoofed requests.
      impact: |
        - Helps verify authenticity of incoming Stripe webhook traffic
        - Detects and blocks non-Stripe or spoofed clients
      code_examples:
        # JavaScript — COMPLIANT: Validates User-Agent for Stripe
        - compliant: |
            app.use("/webhook", (req, res, next) => {
              if (req.headers["user-agent"] !== "Stripe/1.0 (+https://stripe.com)") {
                return res.status(400).send("Invalid User-Agent");
              }
              next();
            });

        # JavaScript — NON-COMPLIANT: No User-Agent validation
        - non_compliant: |
            app.post("/webhook", (req, res) => {
              handleWebhook(req.body); // No header checks
              res.sendStatus(200);
            });

    - title: "Webhook Replay Protection via Timestamp Validation"
      severity: High
      required_context: Webhook Security Validation
      software_version: all
      reference_link:
        - https://stripe.com/docs/webhooks/signatures
      description: |
        Webhook consumers must reject events with timestamps older than a defined tolerance window (e.g., 5 minutes).
      impact: |
        - Prevents duplicate or replayed webhook events
        - Strengthens trust in event timing and sequencing
        - Enhances API security posture for time-sensitive operations
      code_examples:
        # JavaScript — COMPLIANT: Validates Stripe webhook timestamp within 5-minute tolerance
        - compliant: |
            const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);
            const endpointSecret = "whsec_...";
            const sigHeader = req.headers["stripe-signature"];
            let event;

            try {
              event = stripe.webhooks.constructEvent(req.body, sigHeader, endpointSecret, {
                tolerance: 300  // 5 minutes
              });
            } catch (err) {
              return res.status(400).send(`Webhook Error: ${err.message}`);
            }

            // Proceed with validated request
            res.status(200).send("OK");

        # JavaScript — NON-COMPLIANT: No timestamp validation
        - non_compliant: |
            // Missing replay protection logic
            app.post("/webhook", (req, res) => {
              const event = req.body;
              processEvent(event); // No timestamp/tolerance check
              res.sendStatus(200);
            });

    - title: "Secure Webhook Queuing Pattern"
      severity: Medium
      required_context: Webhook Handler Implementation
      software_version: all
      reference_link:
        - https://stripe.com/docs/webhooks
      description: |
        Webhook handlers must enqueue events to background workers or queues before returning a 2xx response, and must not perform synchronous external calls or database writes in the request thread.
      impact: |
        - Prevents blocking operations and retry delays from webhook providers
        - Reduces risk of data duplication or partial failures
        - Ensures consistent and scalable webhook processing
      code_examples:
        # JavaScript — COMPLIANT: Asynchronously enqueues event with error handling
        - compliant: |
            const express = require("express");
            const app = express();
            const bodyParser = require("body-parser");
            const queue = require("./my-queue-client"); // e.g. Redis, SQS, etc.

            app.use(bodyParser.json());

            app.post("/webhook", async (req, res) => {
              const event = req.body;

              try {
                await queue.enqueue(event);  // Wait for confirmation
                res.status(200).send("Queued");
              } catch (err) {
                console.error("Failed to enqueue webhook event:", err);
                res.status(500).send("Failed to process event");
              }
            });

        # JavaScript — NON-COMPLIANT: Synchronous external call in webhook handler
        - non_compliant: |
            app.post("/webhook", async (req, res) => {
              const event = req.body;

              // Unsafe: directly saving to DB in request thread
              await database.save(event);

              res.status(200).send("Saved"); // Delayed response, risk of timeout
            });

  - name: "PaymentIntent & SetupIntent Patterns"
    paths:
      - "**/payment/**"
      - "**/checkout/**"
      - "**/billing/**"
      - "**/subscription/**"
      - "**/intent/**"
    policies:
    - title: "Use PaymentIntent for Charging Customers"
      severity: High
      required_context: Charging Customers
      software_version: all
      reference_link:
        - https://stripe.com/docs/payments/payment-intents
      description: |
        Always use the PaymentIntent API when charging customers.
      impact: |
        - Ensures compliance with EU PSD2 regulations and SCA enforcement
        - Enables support for multi-step payment flows and retries
        - Prevents race conditions associated with direct charge creation
      code_examples:
        # JavaScript — COMPLIANT: Uses PaymentIntent with proper SCA support
        - compliant: |
            const paymentIntent = await stripe.paymentIntents.create({
              amount: 2000,
              currency: 'usd',
              payment_method: 'pm_card_visa',
              confirmation_method: 'automatic',
              confirm: true
            });

        # JavaScript — NON-COMPLIANT: Uses Charges API, which lacks modern support
        - non_compliant: |
            const charge = await stripe.charges.create({
              amount: 2000,
              currency: 'usd',
              source: 'tok_visa'
            });

    - title: "Use SetupIntent for Vaulting Payment Methods"
      severity: Medium
      required_context: Vaulting / Saving Payment Methods
      software_version: all
      reference_link:
        - https://stripe.com/docs/payments/save-and-reuse
        - https://stripe.com/docs/api/setup_intents
      description: |
        Always use Stripe’s SetupIntent API to collect and store customer payment methods for future use. Specify the usage parameter as on_session or off_session based on how the method will be used. Do not attach a source directly to a customer for vaulting. Deprecated or implicit flows should be avoided in all new integrations.
      impact: |
        - Ensures SCA-compliant vaulting aligned with PSD2 regulations
        - Avoids failed payments during future off-session transactions
        - Provides a secure, auditable method of storing payment methods
      code_examples:
        # JavaScript — COMPLIANT: Uses SetupIntent with 'off_session' usage for future background billing
        - compliant: |
            const setupIntent = await stripe.setupIntents.create({
              customer: 'cus_123',
              payment_method_types: ['card'],
              usage: 'off_session'
            });

        # JavaScript — NON-COMPLIANT: Uses deprecated vaulting with implicit 'source' attachment
        - non_compliant: |
            const customer = await stripe.customers.create({
              source: 'tok_visa' // Implicit and insecure vaulting
            });

    - title: "Detect and Handle 3DS Authentication Status"
      severity: High
      required_context: Payment Authentication / SCA
      software_version: all
      reference_link:
        - https://stripe.com/docs/payments/payment-intents/web#handling-next-actions
        - https://stripe.com/docs/strong-customer-authentication
      description: |
        When using Stripe's PaymentIntent, check if the status is requires_action and initiate 3DS authentication using Stripe.js.
      impact: |
        - Ensures proper support for Strong Customer Authentication (SCA)
        - Reduces silent failures from incomplete authentication flows
      code_examples:
        # JavaScript — COMPLIANT: Fully handles 3DS challenge using Stripe.js
        - compliant: |
            const result = await stripe.confirmCardPayment(clientSecret, {
              payment_method: {
                card: cardElement,
              }
            });

            if (result.error) {
              console.error(result.error.message);
            } else if (result.paymentIntent.status === "requires_action") {
              const nextResult = await stripe.confirmCardPayment(clientSecret);
              if (nextResult.error) {
                console.error(nextResult.error.message);
              } else if (nextResult.paymentIntent.status === "succeeded") {
                console.log("Payment succeeded with 3DS authentication");
              }
            } else if (result.paymentIntent.status === "succeeded") {
              console.log("Payment succeeded without 3DS");
            }

        # JavaScript — NON-COMPLIANT: Ignores status and skips 3DS handling
        - non_compliant: |
            const result = await stripe.confirmCardPayment(clientSecret, {
              payment_method: {
                card: cardElement,
              }
            });

            // No check for requires_action status
            // No retry logic for 3DS handling
            if (result.error) {
              console.error(result.error.message);
            } else {
              console.log("Payment status:", result.paymentIntent.status);
            }

    - title: "Require SetupIntent for Off-Session Payment Methods"
      severity: High
      required_context: Off-Session Payments / Card Vaulting
      software_version: all
      reference_link:
        - https://stripe.com/docs/payments/save-and-reuse
        - https://stripe.com/docs/payments/payment-intents#handling-next-actions
      description: |
        When storing payment methods for later off-session use, code must include a SetupIntent to securely save the payment method.
      impact: |
        - Enables secure off-session or recurring payments using saved cards
        - Prevents payment failures due to missing authentication setup
        - Ensures compliance with SCA and other card network requirements
      code_examples:
        # JavaScript — COMPLIANT: Uses SetupIntent to store card for off-session use
        - compliant: |
            // Save card using SetupIntent
            const setupIntent = await stripe.setupIntents.create({
              customer: "cus_123",
              payment_method: "pm_card_visa",
              usage: "off_session"
            });

            // Use saved card in off-session PaymentIntent
            const paymentIntent = await stripe.paymentIntents.create({
              amount: 5000,
              currency: "usd",
              customer: "cus_123",
              payment_method: "pm_card_visa",
              off_session: true,
              confirm: true,
            });

        # JavaScript — NON-COMPLIANT: No SetupIntent used for saving card
        - non_compliant: |
            // Directly using payment method off-session without SetupIntent
            const paymentIntent = await stripe.paymentIntents.create({
              amount: 5000,
              currency: "usd",
              customer: "cus_123",
              payment_method: "pm_card_visa",
              off_session: true,
              confirm: true,
            });

    - title: "Consistency Across Client and Server"
      severity: Medium
      required_context: PaymentIntent / SetupIntent Integration
      software_version: all
      reference_link:
        - https://stripe.com/docs/payments/confirm-card-payment
      description: |
        Confirm a PaymentIntent or SetupIntent on either the client or the server, but not both.
      impact: |
        - Prevents race conditions, duplicate charges, or missed confirmations
        - Ensures consistent payment behavior across devices and environments
      code_examples:
        # JavaScript — COMPLIANT: Client-side confirmation only
        - compliant: |
            const result = await stripe.confirmCardPayment(clientSecret, {
              payment_method: {
                card: cardElement,
                billing_details: { name: 'Customer Name' }
              }
            });

        # JavaScript — NON-COMPLIANT: Confirms on both client and server
        - non_compliant: |
            // Client-side confirmation
            await stripe.confirmCardPayment(clientSecret, {
              payment_method: {
                card: cardElement,
                billing_details: { name: 'Customer Name' }
              }
            });

            // Then (incorrectly) confirms again on server-side
            const paymentIntent = await stripe.paymentIntents.confirm(intentId);

    - title: "Explicit Field Usage in Payment and Setup Intents"
      severity: Low
      required_context: Developer Enablement & Payments Integration
      software_version: all
      reference_link:
        - https://stripe.com/docs/payments/payment-intents
        - https://stripe.com/docs/payments/setup-intents
      description: |
        When using PaymentIntent or SetupIntent, always specify critical fields explicitly such as `usage`, `confirmation_method`, and `off_session`.
      impact: |
        - Avoids unintended defaults that may cause errors or require retries
        - Improves integration clarity and developer understanding
      code_examples:
        # Python — COMPLIANT: All fields specified
        - compliant: |
            intent = stripe.PaymentIntent.create(
                amount=2000,
                currency='usd',
                customer=customer_id,
                payment_method=payment_method_id,
                confirmation_method='manual',
                confirm=True,
                off_session=True
            )

            setup_intent = stripe.SetupIntent.create(
                customer=customer_id,
                payment_method=payment_method_id,
                usage='off_session',
            )

        # Python — NON-COMPLIANT: Omits required fields
        - non_compliant: |
            # Missing confirmation_method and off_session
            intent = stripe.PaymentIntent.create(
                amount=2000,
                currency='usd',
                customer=customer_id,
                payment_method=payment_method_id,
                confirm=True,
            )

            # Missing usage field
            setup_intent = stripe.SetupIntent.create(
                customer=customer_id,
                payment_method=payment_method_id,
            )

  - name: "Customer & Payment-Method Lifecycle"
    paths:
      - "**/payments/**/*.ts"
      - "**/payments/**/*.js"
      - "**/billing/**/*.ts"
      - "**/billing/**/*.js"
      - "**/checkout/**/*.ts"
      - "**/checkout/**/*.js"
      - "**/stripe/**/*.ts"
      - "**/stripe/**/*.js"
      - "**/customers/**/*.ts"
      - "**/customers/**/*.js"
    policies:
    - title: "Reuse Customer Objects Across Transactions"
      severity: Medium
      required_context: Customer Management & Payments Integration
      software_version: all
      reference_link:
        - https://stripe.com/docs/payments/save-and-reuse
        - https://stripe.com/docs/api/customers
      description: |
        Always reuse a previously created Stripe `Customer` object for users who make more than one transaction. Do not create a new customer for each payment attempt.
      impact: |
        - Enables reuse of saved payment methods and billing history
        - Improves fraud detection accuracy
        - Prevents billing fragmentation and data bloat
        - Supports off-session and subscription flows smoothly
      code_examples:
        # JavaScript — COMPLIANT: Reuses existing customer object across transactions
        - compliant: |
            // Lookup stored Stripe customer ID from database
            const existingCustomerId = await getStripeCustomerId(userId);

            // Create a PaymentIntent using the existing customer
            const paymentIntent = await stripe.paymentIntents.create({
              amount: 3000,
              currency: 'usd',
              customer: existingCustomerId,
              payment_method: paymentMethodId,
              confirm: true,
            });

        # JavaScript — NON-COMPLIANT: Creates a new customer on every transaction
        - non_compliant: |
            // Creates a new customer unnecessarily — causes duplication
            const newCustomer = await stripe.customers.create({
              email: userEmail,
            });

            // Associates PaymentIntent with a fresh customer instead of reusing
            const paymentIntent = await stripe.paymentIntents.create({
              amount: 3000,
              currency: 'usd',
              customer: newCustomer.id,
              payment_method: paymentMethodId,
              confirm: true,
            });

    - title: "Detach Stale or Invalid Payment Methods"
      severity: Medium
      required_context: Customer & Payment‑Method Lifecycle Management
      software_version: all
      reference_link:
        - https://stripe.com/docs/api/payment_methods/detach
        - https://stripe.com/docs/payments/payment-methods#detaching
      description: |
        Use Stripe’s `detach()` API to remove known expired, failing, or unused payment methods from a customer account. Ensure detachment logic is idempotent and does not remove valid active methods.
      impact: |
        - Prevents failed or unnecessary retry attempts
        - Improves payment success rate and user satisfaction
        - Keeps customer profiles clean and up-to-date
      code_examples:
        # JavaScript — COMPLIANT: Detaches only expired or failing methods with idempotent and validated logic
        - compliant: |
            const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);

            async function detachIfInvalid(paymentMethodId) {
              // Retrieve payment method details
              const paymentMethod = await stripe.paymentMethods.retrieve(paymentMethodId);

              // Check if it's already detached or inactive
              if (paymentMethod.customer && paymentMethod.card && paymentMethod.card.checks.cvc_check === 'fail') {
                try {
                  await stripe.paymentMethods.detach(paymentMethodId);
                  console.log(`Detached invalid payment method: ${paymentMethodId}`);
                } catch (err) {
                  console.error('Failed to detach payment method:', err.message);
                }
              } else {
                console.log(`Payment method ${paymentMethodId} is still valid and active.`);
              }
            }

            detachIfInvalid('pm_failed_or_expired_123');

        # JavaScript — NON-COMPLIANT: Reuses invalid method without attempting to detach or validate
        - non_compliant: |
            const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);

            // Using a known failing payment method directly — no detachment or validity check
            const intent = await stripe.paymentIntents.create({
              amount: 2500,
              currency: 'usd',
              customer: customerId,
              payment_method: 'pm_failed_or_expired_123',
              confirm: true,
            });

            // This can result in a failed payment attempt

    - title: "Avoid Overriding default_payment_method in Subscriptions Without Justification"
      severity: Medium
      required_context: Subscription Creation / Billing Configuration
      software_version: all
      reference_link:
        - https://stripe.com/docs/billing/subscriptions/payment-methods
        - https://stripe.com/docs/api/subscriptions/create
      description: |
        Avoid explicitly passing `default_payment_method` in `subscriptions.create()` unless required by business logic or user selection.
      impact: |
        - Prevents unexpected billing behavior due to silent overrides
        - Encourages correct use of defaults already configured at the Customer level
        - Supports predictable and user-aligned payment flows
      code_examples:
        # JavaScript — COMPLIANT: Does not override default_payment_method
        - compliant: |
            const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);

            const subscription = await stripe.subscriptions.create({
              customer: customerId,
              items: [{ price: priceId }],
              expand: ['latest_invoice.payment_intent'],
            });

        # JavaScript — NON-COMPLIANT: Unnecessarily overrides default_payment_method
        - non_compliant: |
            const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);

            const subscription = await stripe.subscriptions.create({
              customer: customerId,
              items: [{ price: priceId }],
              default_payment_method: 'pm_123456789',  // Unnecessary override
              expand: ['latest_invoice.payment_intent'],
            });

    - title: "Attach PaymentMethod to the Correct Customer"
      severity: Medium
      required_context: Customer & Payment‑Method Lifecycle Management
      software_version: all
      reference_link:
        - https://stripe.com/docs/api/payment_methods/attach
        - https://stripe.com/docs/payments/payment-methods/overview
      description: |
        Attach each `PaymentMethod` only after confirming it is not already attached and that it belongs to the intended `Customer`.  
        Use fingerprint-based checks to detect and avoid duplicates.
      impact: |
        - Reduces risk of charging the wrong customer
        - Prevents data inconsistencies and billing confusion
        - Strengthens security and regulatory compliance
      code_examples:
        # Python — COMPLIANT: Validates ownership and prevents redundant or duplicate attachment
        - compliant: |
            payment_method = stripe.PaymentMethod.retrieve(payment_method_id)

            # Raise if attached to another customer
            if payment_method.customer and payment_method.customer != customer_id:
                raise Exception("Payment method already attached to a different customer")

            # Check for fingerprint duplicates BEFORE attachment
            if is_duplicate_fingerprint(customer_id, payment_method.fingerprint):
                raise Exception("Duplicate payment method detected for this customer")

            # Attach if not yet linked
            if not payment_method.customer:
                stripe.PaymentMethod.attach(
                    payment_method_id,
                    customer=customer_id
                )

        # Python — NON-COMPLIANT: Attaches without ownership validation or deduplication
        - non_compliant: |
            # Does not check if the payment method is already attached to another customer
            stripe.PaymentMethod.attach(
                payment_method_id,
                customer=customer_id
            )

            # Later logic charges with the same method without checking for duplicates
            stripe.PaymentIntent.create(
                amount=3000,
                currency="usd",
                customer=customer_id,
                payment_method=payment_method_id,
                confirm=True
            )

    - title: "Monitor Payment Method Usage"
      severity: Medium
      required_context: Customer & Payment‑Method Lifecycle Management
      software_version: all
      reference_link:
        - https://stripe.com/docs/payments/payment-methods/lifecycle
      description: |
        Track the last successful usage of each payment method and mark methods as stale if inactive beyond a defined threshold.
      impact: |
        - Keeps customer records clean and manageable
        - Reduces risk of retrying with stale or expired methods
        - Improves UX by surfacing relevant and active options
      code_examples:
        # JavaScript — COMPLIANT: Flags and detaches stale payment methods based on last usage
        - compliant: |
            const stripe = require("stripe")(process.env.STRIPE_SECRET_KEY);

            const THRESHOLD_DAYS = 180;
            const thresholdMillis = THRESHOLD_DAYS * 24 * 60 * 60 * 1000;

            const lastUsed = new Date(getLastUsedTimestamp(paymentMethodId)); // Assume you track usage timestamps
            const now = new Date();

            if (now - lastUsed > thresholdMillis) {
              await stripe.paymentMethods.update(paymentMethodId, {
                metadata: {
                  status: "stale",
                  flagged_at: now.toISOString(),
                },
              });

              await stripe.paymentMethods.detach(paymentMethodId); // Optional
            }

        # JavaScript — NON-COMPLIANT: Does not track or clean up inactive methods
        - non_compliant: |
            const stripe = require("stripe")(process.env.STRIPE_SECRET_KEY);

            const paymentMethods = await stripe.paymentMethods.list({
              customer: customerId,
              type: "card",
            });

            // No logic to track last use or flag/remove stale entries

    - title: "Implement Webhook Handlers for Customer and Payment Events"
      severity: Medium
      required_context: Customer & Payment‑Method Lifecycle Management
      software_version: all
      reference_link:
        - https://stripe.com/docs/webhooks#best-practices
      description: |
        Source code must define webhook handlers for Stripe events like `customer.updated`, `payment_method.attached`, and `payment_method.detached`, and forward relevant data to billing update functions.
      impact: |
        - Ensures internal systems have entry points for Stripe-originated changes
        - Enables accurate billing state without relying solely on frontend changes
        - Reduces drift between Stripe and backend billing records
      code_examples:
        # JavaScript — COMPLIANT: Defines webhook handler for key Stripe events
        - compliant: |
            app.post('/webhook', express.raw({ type: 'application/json' }), (req, res) => {
              const event = JSON.parse(req.body);
              const data = event.data.object;

              switch (event.type) {
                case 'customer.updated':
                  updateBillingSystem(data.id, {
                    default_payment_method: data.invoice_settings?.default_payment_method
                  });
                  break;

                case 'payment_method.attached':
                  logSyncEvent(data.id, 'attached', data.customer);
                  break;

                case 'payment_method.detached':
                  logSyncEvent(data.id, 'detached', data.customer);
                  break;
              }

              res.status(200).send();
            });

        # JavaScript — NON-COMPLIANT: No webhook handler defined
        - non_compliant: |
            // Backend lacks any listener for Stripe events
            // Billing system only updates based on frontend changes
            function updateCustomerBillingInfo(customerId, paymentMethodId) {
              fetch('/api/update-billing', {
                method: 'POST',
                body: JSON.stringify({
                  customerId: customerId,
                  paymentMethod: paymentMethodId
                }),
                headers: {
                  'Content-Type': 'application/json'
                }
              });
            }

  - name: "Subscription & Usage-Based Billing"
    paths:
      - "**/subscriptions/**/*.ts"
      - "**/subscriptions/**/*.js"
      - "**/billing/subscriptions/**/*.ts"
      - "**/billing/subscriptions/**/*.js"
      - "**/usage/**/*.ts"
      - "**/usage/**/*.js"
      - "**/stripe/subscriptions/**/*.ts"
      - "**/stripe/subscriptions/**/*.js"
      - "**/plans/**/*.ts"
      - "**/plans/**/*.js"
    policies:
    - title: "Use One Subscription Integration Method Per Flow"
      severity: Medium
      required_context: Subscription Flow Design & Billing Integration
      software_version: all
      reference_link:
        - https://stripe.com/docs/billing/subscriptions/integrating
        - https://stripe.com/docs/payments/checkout
      description: |
        Use a single integration method—either Stripe Checkout or the Subscriptions API—for each subscription flow, and avoid mixing them within the same journey unless explicitly isolated and managed with lifecycle controls and webhook reconciliation.
      impact: |
        - Avoids race conditions and billing inconsistencies
        - Simplifies subscription lifecycle management and debugging
        - Ensures predictable integration behavior for developers
      code_examples:
        # Python — COMPLIANT: Using Stripe Checkout exclusively
        - compliant: |
            session = stripe.checkout.Session.create(
                mode='subscription',
                customer=customer_id,
                line_items=[{'price': price_id, 'quantity': 1}],
                success_url='https://example.com/success',
                cancel_url='https://example.com/cancel'
            )

        # Python — COMPLIANT: Using Subscriptions API exclusively
        - compliant: |
            subscription = stripe.Subscription.create(
                customer=customer_id,
                items=[{'price': price_id}],
                trial_period_days=14,
                metadata={'plan': 'starter'}
            )

        # Python — NON-COMPLIANT: Mixing Checkout and direct Subscription API operations
        - non_compliant: |
            session = stripe.checkout.Session.create(
                mode='subscription',
                customer=customer_id,
                line_items=[{'price': price_id}]
            )

            stripe.Subscription.modify(
                session.subscription,
                billing_cycle_anchor='now'
            )  # Risk of inconsistency or duplicate billing

    - title: "Setting Up and Managing Subscriptions"
      severity: Medium
      required_context: Subscription Lifecycle Management
      software_version: all
      reference_link:
        - https://stripe.com/docs/billing/subscriptions/overview
        - https://stripe.com/docs/billing/subscriptions/trials
      description: |
        Configure all required subscription fields when creating a subscription, including trial periods, billing anchors, price objects, and default payment methods.
      impact: |
        - Enables predictable billing cycles and trial experiences
        - Reduces payment failures by ensuring billing-ready configurations
        - Supports consistent product-tier mapping and reporting
      code_examples:
        # JavaScript — COMPLIANT: Creating subscription with trial and billing anchor
        - compliant: |
            const subscription = await stripe.subscriptions.create({
              customer: customerId,
              items: [{ price: priceId }],
              default_payment_method: paymentMethodId,
              trial_period_days: 14,
              billing_cycle_anchor: 'now',
              payment_behavior: 'default_incomplete',
            });

        # JavaScript — COMPLIANT: Creating subscription with trial settings and collection method
        - compliant: |
            const subscription = await stripe.subscriptions.create({
              customer: customerId,
              items: [{ price: priceId }],
              default_payment_method: paymentMethodId,
              trial_settings: {
                end_behavior: { missing_payment_method: 'pause' }
              },
              collection_method: 'charge_automatically',
              payment_behavior: 'default_incomplete',
            });

        # JavaScript — NON-COMPLIANT: Subscription created without payment method or billing anchor
        - non_compliant: |
            const subscription = await stripe.subscriptions.create({
              customer: customerId,
              items: [{ price: priceId }],
            });  // Risk of payment failures or misaligned billing

    - title: "Metered Usage and Usage Synchronization"
      severity: Medium
      required_context: Metered Billing & Usage Tracking
      software_version: all
      reference_link:
        - https://stripe.com/docs/billing/subscriptions/metered-billing
        - https://stripe.com/docs/api/usage_records
      description: |
        For metered billing, report usage to Stripe using the `usage_records` endpoint and include a timestamp to align usage with the correct billing period.
      impact: |
        - Enables precise and fair billing based on actual usage
        - Prevents overcharges or undercharges due to lost or duplicated data
        - Supports trust and auditability in subscription reporting
      code_examples:
        # JavaScript — COMPLIANT: Reporting usage for a metered subscription item promptly
        - compliant: |
            await stripe.subscriptionItems.createUsageRecord(subscriptionItemId, {
              quantity: usageAmount,
              timestamp: Math.floor(Date.now() / 1000),
              action: 'increment',
            });

        # JavaScript — COMPLIANT: Scheduled sync batching usage reporting with timestamps
        - compliant: |
            const usageData = await collectUsageForPeriod(startTime, endTime);
            for (const entry of usageData) {
              await stripe.subscriptionItems.createUsageRecord(entry.subscriptionItemId, {
                quantity: entry.amount,
                timestamp: entry.timestamp,
                action: 'set',
              });
            }

        # JavaScript — NON-COMPLIANT: Missing timestamp or deduplication leading to inaccurate billing
        - non_compliant: |
            await stripe.subscriptionItems.createUsageRecord(subscriptionItemId, {
              quantity: 100,
              action: 'increment',
            });  // May lead to inaccurate billing if not timestamped correctly

    - title: "Proration Handling"
      severity: Medium
      required_context: Subscription Changes & Billing Adjustments
      software_version: all
      reference_link:
        - https://stripe.com/docs/billing/subscriptions/prorations
        - https://stripe.com/docs/api/subscriptions/update
      description: |
        When modifying subscriptions mid-cycle, explicitly set the `proration_behavior` field to control how prorated charges or credits are applied.
      impact: |
        - Prevents confusion or disputes from unannounced charges
        - Enables smooth plan transitions without manual adjustments
        - Supports accurate, real-time billing for usage-based or dynamic plans
      code_examples:
        # JavaScript — COMPLIANT: Updating subscription with proration and previewing invoice
        - compliant: |
            // Updating subscription with proration enabled
            await stripe.subscriptions.update(subscriptionId, {
              items: [{ id: subscriptionItemId, price: newPriceId }],
              proration_behavior: 'create_prorations',
            });

            // Preview invoice before applying change
            const invoice = await stripe.invoices.retrieveUpcoming({
              customer: customerId,
              subscription: subscriptionId,
            });

            // (Optional) Display proration amount to user in the UI

        # JavaScript — NON-COMPLIANT: Updating subscription without specifying proration behavior
        - non_compliant: |
            await stripe.subscriptions.update(subscriptionId, {
              items: [{ id: subscriptionItemId, price: newPriceId }],
            });  // May default to unexpected proration behavior

    - title: "Scheduled Upgrades and Downgrades"
      severity: Medium
      required_context: Subscription Scheduling & Lifecycle Management
      software_version: all
      reference_link:
        - https://stripe.com/docs/billing/subscriptions/schedule-updates
        - https://stripe.com/docs/api/subscriptions/update
      description: |
        Use the `pending_update` field to schedule subscription changes that take effect at the end of the current billing cycle.
      impact: |
        - Prevents accidental overcharging or duplicate billing
        - Enables customer flexibility while maintaining billing accuracy
        - Supports better retention by aligning changes with customer intent
      code_examples:
        # JavaScript — COMPLIANT: Scheduling a plan change for next billing cycle using `pending_update`
        - compliant: |
            await stripe.subscriptions.update(subscriptionId, {
              pending_update: {
                items: [{ id: subscriptionItemId, price: newPriceId }],
              },
            });

        # JavaScript — NON-COMPLIANT: Immediate mid-cycle plan change without scheduling or proration
        - non_compliant: |
            await stripe.subscriptions.update(subscriptionId, {
              items: [{ id: subscriptionItemId, price: newPriceId }],
            });  // May cause unexpected charges or loss of access timing

    - title: "Invoicing and Payment Behavior"
      severity: Medium
      required_context: Invoice Generation & Payment Collection
      software_version: all
      reference_link:
        - https://stripe.com/docs/billing/invoices/workflow
        - https://stripe.com/docs/api/invoices/create
      description: |
        Configure the invoice `collection_method` to either `charge_automatically` or `send_invoice` and align the `auto_advance` field accordingly.
      impact: |
        - Supports clear, reliable billing processes
        - Prevents missed or duplicate charges
        - Enables accurate financial reporting and customer communication
      code_examples:
        # JavaScript — COMPLIANT: Create manual invoices and handle payment success webhook
        - compliant: |
            // Creating an invoice for manual payment
            await stripe.invoices.create({
              customer: customerId,
              collection_method: 'send_invoice',
              days_until_due: 14,
              auto_advance: false,
            });

            // Finalizing the invoice manually before sending
            await stripe.invoices.finalizeInvoice(invoiceId);

            // Listening for webhook to reconcile manual payment
            if (event.type === 'invoice.payment_succeeded') {
              const invoice = event.data.object;
              markInvoiceAsPaid(invoice.id);
            }

        # JavaScript — NON-COMPLIANT: Using automatic collection in a manual workflow
        - non_compliant: |
            // Intended for manual payment, but configured for auto-charge
            await stripe.invoices.create({
              customer: customerId,
              collection_method: 'charge_automatically',
              auto_advance: false,
            });  // Misaligned configuration: auto-charge should use auto_advance: true

    - title: "Subscription Lifecycle Management"
      severity: Medium
      required_context: Subscription Status Tracking & Automation
      software_version: all
      reference_link:
        - https://stripe.com/docs/billing/subscriptions/lifecycle
        - https://stripe.com/docs/webhooks/subscriptions
      description: |
        Track subscription status changes in your application logic.
      impact: |
        - Ensures customers have appropriate access based on payment status
        - Enables proactive handling of failed payments and cancellations
        - Prevents misuse or unauthorized access after subscription expiration
      code_examples:
        # JavaScript — COMPLIANT: Handle subscription status updates and manage access
        - compliant: |
            // Handling subscription update webhook
            if (event.type === 'customer.subscription.updated') {
              const subscription = event.data.object;
              updateUserAccess(subscription.customer, subscription.status);
            }

            // Access control logic based on subscription status
            switch (subscription.status) {
              case 'active':
              case 'trialing':
                grantAccess(subscription.customer);
                break;
              case 'past_due':
              case 'canceled':
                restrictAccess(subscription.customer);
                break;
            }

        # JavaScript — NON-COMPLIANT: No subscription status monitoring
        - non_compliant: |
            // No monitoring of subscription status
            // User may retain access even after failed payments or cancellation
            const subscription = await stripe.subscriptions.retrieve(subscriptionId);
            grantAccess(subscription.customer);  // Missing status checks → inconsistent behavior

    - title: "Billing Preview Before Subscription Changes"
      severity: Medium
      required_context: Subscription UI/UX Design & Billing Transparency
      software_version: all
      reference_link:
        - https://stripe.com/docs/billing/subscriptions/customer-experience
      description: |
        Always present a billing preview to users before applying any subscription changes, such as upgrades or downgrades.
      impact: |
        - Reduces support requests and disputes
        - Improves trust by making charges predictable
        - Increases confidence during plan changes
      code_examples:
        # JavaScript — COMPLIANT: Show billing preview and allow self-service downgrade
        - compliant: |
            // Retrieve upcoming invoice preview
            const upcoming = await stripe.invoices.retrieveUpcoming({
              customer: customerId,
              subscription: subscriptionId,
            });

            displayBillingSummary(upcoming);  // Show preview to user

            // Proceed with subscription update after confirmation
            await stripe.subscriptions.update(subscriptionId, {
              items: [{ id: subscriptionItemId, price: downgradedPriceId }],
              proration_behavior: 'create_prorations',
            });

        # JavaScript — NON-COMPLIANT: No billing preview before changing subscription
        - non_compliant: |
            await stripe.subscriptions.update(subscriptionId, {
              items: [{ id: subscriptionItemId, price: upgradedPriceId }],
            });  // No preview → user may be surprised by the resulting charge

  - name: "Refunds, Disputes & Reconciliation"
    paths:
      - "**/refunds/**/*.ts"
      - "**/refunds/**/*.js"
      - "**/disputes/**/*.ts"
      - "**/disputes/**/*.js"
      - "**/billing/refunds/**/*.ts"
      - "**/billing/refunds/**/*.js"
      - "**/billing/disputes/**/*.ts"
      - "**/billing/disputes/**/*.js"
      - "**/stripe/refunds/**/*.ts"
      - "**/stripe/refunds/**/*.js"
      - "**/reconciliation/**/*.ts"
      - "**/reconciliation/**/*.js"
      - "**/finance/**/*.ts"
      - "**/finance/**/*.js"
    policies:
    - title: "Programmatic Refund Handling"
      severity: Medium
      required_context: Refund Processing & API Integration
      software_version: all
      reference_link:
        - https://stripe.com/docs/refunds
      description: |
        Use the Stripe Refund API (`/v1/refunds`) to create refunds programmatically in your backend. Avoid relying solely on manual refund actions in the Stripe Dashboard.
      impact: |
        - Enables automated refund policies
        - Reduces human error and operational burden
        - Ensures all refund events are traceable and enforceable in code
      code_examples:
        # JavaScript — COMPLIANT: Programmatically issue refund with backend logic
        - compliant: |
            // Automated refund with idempotency and backend logic
            if (isEligibleForRefund(chargeId)) {
              await stripe.refunds.create({
                charge: chargeId,
                amount: refundAmount,
                idempotency_key: generateKey(chargeId),
              });

              notifyUser("Refund successfully processed.");
            }

        # JavaScript — NON-COMPLIANT: Relies on manual dashboard refund instead of backend
        - non_compliant: |
            // Manual refund instruction passed to ops team
            async function handleRefundRequest(chargeId) {
              await saveRefundRequestToDB(chargeId);
              notifyOpsTeam(`Please refund manually via Stripe Dashboard for charge ${chargeId}`);
            }

            // No use of Stripe Refund API — relies on manual processing

    - title: "Handle Stripe Dispute Events in Code"
      severity: Medium
      required_context: Dispute Management Logic
      software_version: all
      reference_link:
        - https://stripe.com/docs/disputes#responding-to-disputes
      description: |
        Implement application logic to handle Stripe `charge.dispute.*` webhook events when they are received.
      impact: |
        - Enables automated workflows for dispute management
        - Improves response time and traceability
        - Reduces reliance on manual resolution via the Dashboard
      code_examples:
        # JavaScript — COMPLIANT: Handles dispute event in internal logic
        - compliant: |
            if (event.type.startsWith('charge.dispute.')) {
              const dispute = event.data.object;
              handleDispute(dispute);  // Custom internal logic for logging, alerts, etc.
            }

        # JavaScript — NON-COMPLIANT: Ignores dispute-related events
        - non_compliant: |
            // Dispute-related events are ignored
            if (event.type === 'invoice.paid') {
              handleInvoice(event.data.object);
            }

    - title: "Submit Dispute Evidence via Stripe API"
      severity: Medium
      required_context: Dispute Evidence Handling in API Integration
      software_version: all
      reference_link:
        - https://stripe.com/docs/disputes/evidence
      description: |
        Use the Stripe API to programmatically submit dispute evidence.
      impact: |
        - Increases likelihood of successful dispute resolution
        - Automates time-sensitive dispute workflows
        - Ensures consistent and complete evidence submission
      code_examples:
        # JavaScript — COMPLIANT: Submit structured dispute evidence using Stripe API
        - compliant: |
            await stripe.disputes.submit(disputeId, {
              evidence: {
                customer_email_address: customer.email,
                customer_name: customer.name,
                shipping_tracking_number: trackingNumber,
                service_date: serviceDate,
                billing_address: billingAddress,
                access_activity_log: activityLogUrl,
                refund_policy: policyText,
              }
            });

        # JavaScript — NON-COMPLIANT: Incomplete and incorrect evidence submission
        - non_compliant: |
            // Incomplete evidence and incorrect API usage
            await stripe.disputes.update(disputeId, {
              evidence: {
                customer_email_address: customer.email
                // Missing other critical evidence fields
              }
            });  // No call to disputes.submit, weak evidence submission

    - title: "Reconcile Payouts With Internal Accounting"
      severity: Medium
      required_context: Financial Reporting & Revenue Reconciliation
      software_version: all
      reference_link:
        - https://stripe.com/docs/reports/reconciliation
      description: |
        Use Stripe’s `payout` and `balance_transaction` APIs to reconcile deposited funds with internal records. Match each balance transaction to accounting entries and retain transaction and payout IDs for traceability.
      impact: |
        - Reduces errors in financial statements
        - Enables faster month-end close processes
        - Supports audit readiness and traceable revenue workflows
      code_examples:
        # JavaScript — COMPLIANT: Retrieve payout transactions and perform reconciliation
        - compliant: |
            // Retrieve payout and associated balance transactions
            const payout = await stripe.payouts.retrieve(payoutId);
            const transactions = await stripe.balanceTransactions.list({
              payout: payout.id,
              limit: 100,
            });

            // Record details of each transaction internally
            for (const tx of transactions.data) {
              recordTransaction(tx.id, tx.amount, tx.type, tx.fee);
            }

            // Schedule daily reconciliation job
            scheduleReconciliationJob('stripe', 'daily');

            // Alert finance team if unmatched transactions found
            if (detectUnmatchedTransactions(transactions.data)) {
              alertFinanceTeam("Unmatched Stripe payout transactions detected.");
            }

        # JavaScript — NON-COMPLIANT: Reconcile only total payout, not individual transactions
        - non_compliant: |
            // Retrieve payout but skip balance transaction details
            const payout = await stripe.payouts.retrieve(payoutId);

            // Log only total payout amount, skipping fees and transaction types
            recordTransactionSummary({
              payout_id: payout.id,
              total_amount: payout.amount,
            });

            // No detailed reconciliation or transaction-level logging
            // → May cause discrepancies and audit issues

    - title: "Check Item Fulfillment Before Issuing Partial Refunds"
      severity: Medium
      required_context: Refund Logic in Backend Services
      software_version: all
      reference_link:
        - https://stripe.com/docs/refunds
        - https://stripe.com/docs/api/refunds/create
      description: |
        Before issuing a partial refund using the Stripe Refund API, verify that item-level fulfillment status is checked in code.
      impact: |
        - Promotes explicit refund logic
        - Prevents issuing refunds blindly for fully fulfilled orders
        - Ensures refund logic is defensively written and traceable
      code_examples:
        # JavaScript — COMPLIANT: Filters unfulfilled items before calculating refund
        - compliant: |
            const unfulfilledItems = order.items.filter(item => item.fulfilled === false);
            const refundAmount = calculateRefund(unfulfilledItems);
            await stripe.refunds.create({
              payment_intent: order.payment_intent_id,
              amount: refundAmount,
            });

        # JavaScript — NON-COMPLIANT: No check for fulfillment status
        - non_compliant: |
            // Refund issued without verifying fulfillment status
            await stripe.refunds.create({
              payment_intent: order.payment_intent_id,
              amount: 5000,
            });

    - title: "Call Notification Function After Refund or Dispute"
      severity: Low
      required_context: Refund or Dispute Handling Logic
      software_version: all
      reference_link:
        - https://stripe.com/docs/refunds#customer-communication
        - https://stripe.com/docs/disputes#responding-to-disputes
      description: |
        Call a local notification function in code after initiating a Stripe refund or dispute-related action.
      impact: |
        - Makes notification behavior traceable through code
        - Allows integrations with user-facing systems through clearly defined hooks
        - Enables teams to build alerting pipelines consistently
      code_examples:
        # JavaScript — COMPLIANT: Refund is followed by a notification function call
        - compliant: |
            const refund = await stripe.refunds.create({ payment_intent: paymentIntentId });

            notifyUser(user.id, {
              type: 'refund_initiated',
              data: {
                amount: refund.amount,
                timestamp: new Date().toISOString()
              }
            });

        # JavaScript — NON-COMPLIANT: Refund issued without any notification trigger
        - non_compliant: |
            // Refund is created but no function is called to notify the user
            await stripe.refunds.create({ payment_intent: paymentIntentId });

            // Missing: call to notifyUser() or equivalent

    - title: "Log Refund and Dispute Events with Metadata"
      severity: High
      required_context: Refund and Dispute Operations
      software_version: all
      reference_link:
        - https://stripe.com/docs/api/refunds
        - https://stripe.com/docs/api/disputes
      description: |
        All refund and dispute operations must be logged with structured metadata including timestamps, actor identity, and transaction IDs.
      impact: |
        - Enables traceability for financial operations
        - Supports compliance and incident investigation
      code_examples:
        # JavaScript — COMPLIANT: Logs both refund and dispute events with structured metadata
        - compliant: |
            const refund = await stripe.refunds.create({
              payment_intent: paymentIntentId,
              amount: 5000,
            });

            logEvent('refund_initiated', {
              actor: currentUser.id,
              payment_intent_id: paymentIntentId,
              amount: 5000,
              timestamp: new Date().toISOString(),
            });

            const dispute = await stripe.disputes.retrieve(disputeId);

            logEvent('dispute_accessed', {
              actor: currentUser.id,
              dispute_id: dispute.id,
              reason: dispute.reason,
              timestamp: new Date().toISOString(),
            });

        # JavaScript — NON-COMPLIANT: Refund and dispute actions performed without logging
        - non_compliant: |
            await stripe.refunds.create({
              payment_intent: paymentIntentId,
              amount: 5000,
            });

            await stripe.disputes.retrieve(disputeId);

            // Missing: logEvent() calls for traceability

    - title: "Redact Sensitive Data Before Logging Refund or Dispute Events"
      severity: High
      required_context: Refund and Dispute Logging Code
      software_version: all
      reference_link:
        - https://stripe.com/docs/webhooks/best-practices
      description: |
        Refund and dispute logs must use redaction functions to remove sensitive information before being passed to the logging system.
      impact: |
        - Protects sensitive user and payment data from exposure in logs
        - Encourages consistent use of secure logging practices
      code_examples:
        # JavaScript — COMPLIANT: Logs redacted data using a secure logger
        - compliant: |
            const redacted = redactSensitiveData(stripeResponse);
            secureLogger.log('refund_processed', {
              actor: currentUser.id,
              data: redacted,
            });

        # JavaScript — NON-COMPLIANT: Logs full response without redacting sensitive data
        - non_compliant: |
            console.log('refund_processed', stripeResponse); // May expose PII or card data

  - name: "Localization, Currencies & Tax"
    paths:
      - "**/localization/**/*.ts"
      - "**/localization/**/*.js"
      - "**/i18n/**/*.ts"
      - "**/i18n/**/*.js"
      - "**/currency/**/*.ts"
      - "**/currency/**/*.js"
      - "**/pricing/**/*.ts"
      - "**/pricing/**/*.js"
      - "**/tax/**/*.ts"
      - "**/tax/**/*.js"
      - "**/stripe/tax/**/*.ts"
      - "**/stripe/tax/**/*.js"
      - "**/checkout/tax/**/*.ts"
      - "**/checkout/tax/**/*.js"
    policies:
    - title: "Provide Pricing in Minor Units as Integer"
      severity: High
      required_context: Stripe Pricing API Usage
      software_version: all
      reference_link:
        - https://stripe.com/docs/currencies#zero-decimal
        - https://stripe.com/docs/api/prices/create
      description: |
        Pricing values must be sent to Stripe in the smallest currency unit (e.g., cents for USD) as an integer.
      impact: |
        - Prevents API validation errors
        - Aligns with Stripe's expected pricing format
      code_examples:
        # JavaScript — COMPLIANT: Send integer unit amount
        - compliant: |
            await stripe.prices.create({
              unit_amount: 499,
              currency: 'usd',
              product: 'prod_123',
            });

        # JavaScript — NON-COMPLIANT: Send float instead of integer
        - non_compliant: |
            await stripe.prices.create({
              unit_amount: 4.99,
              currency: 'usd',
              product: 'prod_123',
            });

    - title: "Use Utility Functions to Convert to Minor Units"
      severity: Medium
      required_context: User Input Handling for Stripe Pricing
      software_version: all
      reference_link:
        - https://stripe.com/docs/currencies#zero-decimal
      description: |
        Use conversion utilities to transform user-friendly decimal pricing values into minor units based on the currency type.
      impact: |
        - Avoids currency-specific rounding bugs
        - Ensures consistent minor unit conversions for all currencies
      code_examples:
        # JavaScript — COMPLIANT: Convert based on currency type
        - compliant: |
            function toMinorUnits(amount, currency) {
              const zeroDecimalCurrencies = ['jpy', 'krw', 'vnd'];
              if (zeroDecimalCurrencies.includes(currency.toLowerCase())) {
                return Math.round(amount);
              }
              return Math.round(amount * 100);
            }

            const price = toMinorUnits(9.99, 'usd');

        # JavaScript — NON-COMPLIANT: No conversion utility used
        - non_compliant: |
            const price = 9.99 * 100; // May fail for JPY or cause rounding issues

    - title: "Enable Stripe Multi-Currency Support"
      severity: High
      required_context: Global Billing Support
      software_version: all
      reference_link:
        - https://stripe.com/docs/currencies
        - https://stripe.com/docs/payments/multicurrency
      description: |
        Use Stripe’s multi-currency features when creating Checkout sessions or PaymentIntents to support localized currencies.
      impact: |
        - Improves user trust and conversion by aligning prices with local expectations
        - Reduces currency-related confusion and chargebacks
      code_examples:
        # JavaScript — COMPLIANT: Use Stripe Checkout session with local currency
        - compliant: |
            const session = await stripe.checkout.sessions.create({
              line_items: [{
                price: localizedPriceId, // e.g., a price object in EUR or JPY
                quantity: 1,
              }],
              mode: 'payment',
              locale: 'auto',
              success_url: 'https://example.com/success',
              cancel_url: 'https://example.com/cancel',
            });

        # JavaScript — NON-COMPLIANT: Hardcoding currency without enabling multi-currency
        - non_compliant: |
            const session = await stripe.checkout.sessions.create({
              line_items: [{
                price: 'price_usd_456',  // USD only
                quantity: 1,
              }],
              mode: 'payment',
              locale: 'auto',
            });

    - title: "Dynamically Localize Prices Based on User Locale"
      severity: High
      required_context: Price Selection Logic for International Users
      software_version: all
      reference_link:
        - https://stripe.com/docs/payments/multicurrency
      description: |
        Select appropriate price objects based on the customer’s locale or preferred currency. Use fallbacks if a localized price isn’t available.
      impact: |
        - Ensures users are charged in a familiar and expected currency
        - Prevents issues with price mismatches and miscommunication
      code_examples:
        # JavaScript — COMPLIANT: Localize price selection with fallback
        - compliant: |
            function getLocalizedPriceId(locale, productId) {
              const priceMap = {
                'de-DE': 'price_eur_123',
                'en-US': 'price_usd_456',
                'ja-JP': 'price_jpy_789',
              };
              return priceMap[locale] || priceMap['en-US'];
            }

            const priceId = getLocalizedPriceId(customerLocale, productId);

        # JavaScript — NON-COMPLIANT: No locale logic or fallback
        - non_compliant: |
            const priceId = 'price_usd_456';  // Static pricing not tailored to user

    - title: "Use Locale-Aware Formatting for Price Display"
      severity: Medium
      required_context: User-Facing UI for Price Display
      software_version: all
      reference_link:
        - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat
      description: |
        Use `Intl.NumberFormat` or similar locale-aware tools to format currency values for display.
        Avoid hardcoded symbols or inconsistent formatting across regions.
      impact: |
        - Prevents user confusion due to unfamiliar formats
        - Enhances trust by matching local conventions for numbers and currency
      code_examples:
        # JavaScript — COMPLIANT: Locale-specific formatting
        - compliant: |
            const formattedPrice = new Intl.NumberFormat('de-DE', {
              style: 'currency',
              currency: 'EUR',
            }).format(1000); // → "1.000,00 €"

        # JavaScript — NON-COMPLIANT: Hardcoded formatting
        - non_compliant: |
            const formattedPrice = "$" + price;  // Assumes USD regardless of user

    - title: "Integrate Stripe Tax for Tax Compliance"
      severity: High
      required_context: Sales Tax, VAT, and GST Compliance
      software_version: all
      reference_link:
        - https://stripe.com/tax
        - https://stripe.com/docs/tax
      description: |
        Configure Stripe Checkout to support automatic tax calculation by enabling Stripe Tax, collecting customer address information, and ensuring the `automatic_tax` field is set appropriately in the session object.
      impact: |
        - Ensures automatic and accurate tax calculation across jurisdictions
        - Reduces legal risk related to sales tax, VAT, or GST non-compliance
        - Enhances user trust by showing tax transparency in checkout and invoices
      code_examples:
        # JavaScript — COMPLIANT: Enable Stripe Tax with address collection in Checkout session
        - compliant: |
            await stripe.checkout.sessions.create({
              customer: 'cus_123',
              line_items: [
                {
                  price: 'price_abc',
                  quantity: 1,
                },
              ],
              mode: 'payment',
              customer_update: {
                address: 'auto',  // Collect/update customer address automatically
              },
              automatic_tax: { enabled: true },  // Enable automatic tax calculation
            });

        # JavaScript — NON-COMPLIANT: Omitting tax and address configuration
        - non_compliant: |
            // Missing address collection and tax calculation setup
            await stripe.checkout.sessions.create({
              customer: 'cus_123',
              line_items: [{ price: 'price_abc', quantity: 1 }],
              mode: 'payment',
            });  // Risks inaccurate or missing tax charges

    - title: "Present Locale-Aware Checkout Sessions"
      severity: Medium
      required_context: International Customers, Stripe Checkout Integration
      software_version: all
      reference_link:
        - https://stripe.com/docs/payments/checkout/languages
      description: |
        Set the `locale` parameter when creating a Stripe Checkout Session.
      impact: |
        - Improves conversion rates by presenting payment flows in the user’s native language
        - Enhances accessibility and global user experience
        - Reduces confusion in multi-lingual markets
      code_examples:
        # JavaScript — COMPLIANT: Locale-aware checkout session creation
        - compliant: |
            const session = await stripe.checkout.sessions.create({
              customer: 'cus_123',
              line_items: [{ price: 'price_abc', quantity: 1 }],
              mode: 'payment',
              locale: 'auto', // or specify 'fr', 'es', 'ja', etc.
            });

        # JavaScript — NON-COMPLIANT: Missing locale parameter
        - non_compliant: |
            // No locale specified, Stripe Checkout may default to undesired language
            const session = await stripe.checkout.sessions.create({
              customer: 'cus_123',
              line_items: [{ price: 'price_abc', quantity: 1 }],
              mode: 'payment',
            });

    - title: "Prepare Currency Conversion Notice for Multi-Currency Payments"
      severity: Medium
      required_context: Currency Conversion, Customer Communication
      software_version: all
      reference_link:
        - https://stripe.com/docs/currencies
      description: |
        Include a reusable function, message template, or constant in the codebase that provides a standard currency conversion notice for multi-currency transactions.
      impact: |
        - Encourages consistent display of disclaimers across payment experiences
        - Reduces customer disputes due to currency conversion misunderstandings
        - Enables easier audit and localization of currency messages
      code_examples:
        # JavaScript — COMPLIANT: Define and reuse a standardized currency conversion notice
        - compliant: |
            // Standard conversion disclaimer stored in a reusable constant
            const CURRENCY_NOTICE = "Note: Currency conversion may be applied by Stripe or your bank. Additional fees may apply.";

            // Display it in the payment interface
            showMessage(`Amount: €50.00. ${CURRENCY_NOTICE}`);

        # JavaScript — NON-COMPLIANT: Currency conversion message is missing or inconsistent
        - non_compliant: |
            // No reuse of standardized message, or no notice provided at all
            showMessage("Amount: $50.00");

    - title: "Use External Configuration for Pricing and Tax Logic"
      severity: Medium
      required_context: Currency Pricing Maintenance & Tax Compliance
      software_version: all
      reference_link:
        - https://stripe.com/docs/tax
        - https://stripe.com/docs/currencies
      description: |
        Use externally configurable sources such as environment variables or API-based configuration for pricing and tax-related logic.
      impact: |
        - Allows easy updates to pricing and tax rates without code changes
        - Reduces risk of outdated or incorrect values in production
        - Improves maintainability in international environments
      code_examples:
        # JavaScript — COMPLIANT: Uses external config for pricing and tax setup
        - compliant: |
            const taxRate = process.env.TAX_RATE || 0.2;

            async function getPriceInCurrency(currency) {
              const rates = await fetchExchangeRates();
              return basePrice * rates[currency];
            }

        # JavaScript — NON-COMPLIANT: Uses hard-coded prices and tax values
        - non_compliant: |
            const taxRate = 0.15;

            function getPriceInCurrency(currency) {
              const rates = { USD: 1, EUR: 0.9 };
              return basePrice * rates[currency];
            }

    - title: "Use Internationalization Functions for Locale-Sensitive Formatting"
      severity: Medium
      required_context: Internationalization, Localization, and Pricing Logic
      software_version: all
      reference_link:
        - https://stripe.com/docs/tax
        - https://stripe.com/docs/currencies
      description: |
        Use internationalization (i18n) and localization (l10n) functions to format pricing, tax information, and UI text content based on the user's locale.
      impact: |
        - Ensures correct currency and date formatting across regions
        - Prevents hardcoded and non-translatable UI elements
        - Supports accessibility and consistency in multi-lingual environments
      code_examples:
        # JavaScript — COMPLIANT: Uses Intl API and i18n translations for content
        - compliant: |
            const price = new Intl.NumberFormat(locale, {
              style: 'currency',
              currency: userCurrency,
            }).format(amount);

            const checkoutTitle = translations[locale]?.checkoutTitle || translations['en-US'].checkoutTitle;

        # JavaScript — NON-COMPLIANT: Hardcoded currency formatting and untranslated string
        - non_compliant: |
            const price = '$' + amount.toFixed(2);  // Not locale-aware
            const checkoutTitle = "Checkout";       // Hardcoded string, not translated

  - name: "Strong Customer Authentication (SCA) & 3D Secure"
    paths:
      - "**/payments/sca/**/*.ts"
      - "**/payments/sca/**/*.js"
      - "**/payments/3dsecure/**/*.ts"
      - "**/payments/3dsecure/**/*.js"
      - "**/stripe/sca/**/*.ts"
      - "**/stripe/sca/**/*.js"
      - "**/stripe/3dsecure/**/*.ts"
      - "**/stripe/3dsecure/**/*.js"
      - "**/checkout/sca/**/*.ts"
      - "**/checkout/sca/**/*.js"
    policies:
    - title: "Use PaymentIntent API for SCA-Compliant Payments"
      severity: High
      required_context: Payment Authentication, Regulatory Compliance
      software_version: all
      reference_link:
        - https://stripe.com/docs/payments/payment-intents
        - https://stripe.com/docs/strong-customer-authentication
      description: |
        Use the `paymentIntents.create` API to initiate payments that require Strong Customer Authentication (SCA).
      impact: |
        - Prevents payment declines caused by missing or incomplete authentication
        - Provides a seamless and secure authentication flow for customers
        - Ensures compliance with PSD2 and other regional SCA regulations
      code_examples:
        # JavaScript — COMPLIANT: Uses PaymentIntent with manual confirmation and next action handling
        - compliant: |
            const paymentIntent = await stripe.paymentIntents.create({
              amount: 5000,
              currency: 'eur',
              payment_method: paymentMethodId,
              confirmation_method: 'manual',
              confirm: true,
            });

            if (paymentIntent.status === 'requires_action') {
              handleNextAction(paymentIntent.next_action);
            } else if (paymentIntent.status === 'succeeded') {
              // Payment successful
            } else if (paymentIntent.status === 'requires_payment_method') {
              // Ask for new payment method
            }

        # JavaScript — NON-COMPLIANT: Uses deprecated charges API without SCA handling
        - non_compliant: |
            await stripe.charges.create({
              amount: 5000,
              currency: 'eur',
              source: cardToken,
            });

    - title: "Handle next_action for On-Session Payments"
      severity: High
      required_context: On-Session Payment Flows, 3D Secure Authentication
      software_version: all
      reference_link:
        - https://stripe.com/docs/payments/payment-intents#handling-next-actions
        - https://stripe.com/docs/strong-customer-authentication
      description: |
        For on-session payments, handle the `requires_action` status on the PaymentIntent using the `next_action` object and Stripe.js or mobile SDK. Do not proceed with fulfillment until the authentication flow is completed and confirmed.
      impact: |
        - Reduces payment failures caused by unhandled authentication steps
        - Provides a smooth, secure payment experience for customers
        - Meets regulatory requirements for payment authentication
      code_examples:
        # JavaScript — COMPLIANT: Handles 3DS via Stripe.js and reconfirms intent
        - compliant: |
            if (paymentIntent.status === 'requires_action') {
              stripe.handleCardAction(paymentIntent.client_secret)
                .then(function(result) {
                  if (result.error) {
                    displayError(result.error.message);
                  } else {
                    confirmPaymentOnServer(result.paymentIntent.id);
                  }
                });
            }

        # JavaScript — NON-COMPLIANT: Skips next_action handling and proceeds as if payment succeeded
        - non_compliant: |
            // Incorrectly assuming payment succeeded without checking status
            if (paymentIntent.status === 'succeeded' || paymentIntent.status === 'requires_action') {
              // Fulfills order even when authentication is required
              fulfillOrder(paymentIntent.id);
            }

    - title: "Support Off-Session Payments Securely"
      severity: High
      required_context: Off-Session Payment Flows, Payment Method Setup
      software_version: all
      reference_link:
        - https://stripe.com/docs/payments/save-and-reuse
        - https://stripe.com/docs/payments/payment-intents#handling-next-actions
      description: |
        Use a SetupIntent with `usage: 'off_session'` to save a customer’s payment method for future off-session payments.
      impact: |
        - Enables secure off-session charges by verifying payment method ownership in advance  
        - Minimizes authentication failures and improves subscription reliability  
        - Ensures regulatory compliance with SCA and PSD2 requirements  
      code_examples:
        # JavaScript — COMPLIANT: Uses SetupIntent to save payment method for off-session use
        - compliant: |
            const setupIntent = await stripe.setupIntents.create({
              payment_method: paymentMethodId,
              usage: 'off_session',
              customer: customerId,
            });

        # JavaScript — NON-COMPLIANT: Creates SetupIntent without 'usage', reducing off-session reliability
        - non_compliant: |
            // Fails to specify usage for off-session, defaulting to 'on_session'
            const setupIntent = await stripe.setupIntents.create({
              payment_method: paymentMethodId,
              customer: customerId,
              // Missing: usage: 'off_session'
            });

    - title: "Handle 3D Secure Authentication Outcomes"
      severity: High
      required_context: Payment Authentication Monitoring and Error Handling
      software_version: all
      reference_link:
        - https://stripe.com/docs/payments/payment-intents/webhooks
      description: |
        Use secure, idempotent webhook handlers to process PaymentIntent authentication outcomes such as `succeeded` and `payment_failed`.
      impact: |
        - Ensures consistent handling of authentication results  
        - Reduces risk of duplicate operations and improves system reliability  
        - Enables automated workflows for fulfillment and recovery  
      code_examples:
        # JavaScript — COMPLIANT: Full webhook handler with signature verification and idempotency
        - compliant: |
            const endpointSecret = process.env.STRIPE_WEBHOOK_SECRET;

            app.post('/webhook', express.raw({ type: 'application/json' }), (req, res) => {
              let event;

              try {
                event = stripe.webhooks.constructEvent(req.body, req.headers['stripe-signature'], endpointSecret);
              } catch (err) {
                console.error(`Webhook Error: ${err.message}`);
                return res.status(400).send(`Webhook Error: ${err.message}`);
              }

              const paymentIntent = event.data.object;

              // Idempotency check (example with order ID metadata)
              const orderId = paymentIntent.metadata?.order_id;
              if (hasAlreadyProcessed(orderId)) {
                return res.status(200).send('Already processed');
              }

              if (event.type === 'payment_intent.succeeded') {
                markOrderPaid(orderId);
              } else if (event.type === 'payment_intent.payment_failed') {
                logFailure(orderId, paymentIntent.last_payment_error);
                notifyCustomerPaymentFailure(paymentIntent.customer);
              }

              res.status(200).send('Handled');
            });

        # JavaScript — NON-COMPLIANT: No signature check, no idempotency, and ignores failures
        - non_compliant: |
            app.post('/webhook', (req, res) => {
              const event = req.body; // 🚨 Signature not verified

              if (event.type === 'payment_intent.succeeded') {
                markOrderPaid(event.data.object.metadata.order_id); // 🚫 No idempotency
              }

              res.status(200).send('OK');
            });

    - title: "Implement Retry Logic for SCA Failures"
      severity: High
      required_context: Payment Retry, SCA Enforcement
      software_version: all
      reference_link:
        - https://stripe.com/docs/payments/save-and-reuse
        - https://stripe.com/docs/payments/payment-intents#handling-next-actions
      description: |
        When an off-session payment fails due to `authentication_required`, the system must avoid automatic retries with `off_session: true`, and only retry after collecting customer input (e.g., by setting `off_session: false`).
      impact: |
        - Ensures compliance with SCA regulations  
        - Prevents unauthorized retries that may lead to disputes  
        - Supports authentication flow handling based on PaymentIntent error states  
      code_examples:
        # JavaScript — COMPLIANT: Detects SCA failure and retries with customer interaction
        - compliant: |
            let paymentIntent;

            try {
              paymentIntent = await stripe.paymentIntents.create({
                amount: 3000,
                currency: 'eur',
                customer: customerId,
                payment_method: savedPaymentMethodId,
                off_session: true,
                confirm: true,
              });
            } catch (error) {
              if (error.code === 'authentication_required' && error.payment_intent) {
                // Do not retry off-session
                // Wait for customer interaction before retrying
                const confirmedPayment = await stripe.paymentIntents.confirm(error.payment_intent.id, {
                  off_session: false,
                });
              } else {
                handleOtherErrors(error);
              }
            }

        # JavaScript — NON-COMPLIANT: Retries off-session even after SCA error
        - non_compliant: |
            try {
              const paymentIntent = await stripe.paymentIntents.create({
                amount: 3000,
                currency: 'eur',
                customer: customerId,
                payment_method: savedPaymentMethodId,
                off_session: true,
                confirm: true,
              });
            } catch (error) {
              if (error.code === 'authentication_required' && error.payment_intent) {
                // 🚫 Retry again off-session without prompting user
                await stripe.paymentIntents.confirm(error.payment_intent.id, {
                  off_session: true,
                });
              }
            }

    - title: "Use Webhooks to Handle SCA Events"
      severity: High
      required_context: Real-Time Payment Status, Event Handling
      software_version: all
      reference_link:
        - https://stripe.com/docs/webhooks
      description: |
        Handle Stripe SCA-related events such as `payment_intent.succeeded`, `payment_intent.payment_failed`, and `payment_intent.requires_action` using verified and idempotent webhook handlers.
      impact: |
        - Enables automated handling of payment flow updates
        - Supports customer notification and retry flows
        - Increases payment success rate through timely system updates
      code_examples:
        # JavaScript — COMPLIANT: Secure and complete webhook handler
        - compliant: |
            app.post('/webhook', express.raw({ type: 'application/json' }), (request, response) => {
              let event;

              try {
                event = stripe.webhooks.constructEvent(
                  request.body,
                  request.headers['stripe-signature'],
                  endpointSecret
                );
              } catch (err) {
                console.error(`Webhook signature verification failed: ${err.message}`);
                return response.status(400).send(`Webhook Error: ${err.message}`);
              }

              switch (event.type) {
                case 'payment_intent.succeeded':
                  handlePaymentSuccess(event.data.object);
                  break;
                case 'payment_intent.payment_failed':
                  handlePaymentFailure(event.data.object);
                  break;
                case 'payment_intent.requires_action':
                  promptCustomerAuthentication(event.data.object);
                  break;
                default:
                  console.log(`Unhandled event type ${event.type}`);
              }

              response.json({ received: true });
            });

        # JavaScript — NON-COMPLIANT: Missing signature verification and incomplete event handling
        - non_compliant: |
            // Insecure and incomplete webhook handler
            app.post('/webhook', express.json(), (req, res) => {
              const event = req.body;

              // No signature verification — vulnerable to spoofed events
              if (event.type === 'payment_intent.succeeded') {
                handlePaymentSuccess(event.data.object);
              }

              // Other event types not handled
              res.sendStatus(200);
            });

    - title: "Configure payment_method_options for 3D Secure"
      required_context: 3D Secure Configuration, Risk Management
      severity: Medium
      description: |
        Set the `request_three_d_secure` field under `payment_method_options.card` to control 3DS behavior.  
        Use `'automatic'` (default) to let Stripe decide based on risk, or `'any'` to force 3DS on every transaction.  
        Apply the setting based on transaction context, region, or regulatory need.  
        Adjust configurations according to card network or local compliance requirements.

      software_version: all
      reference_link:
        - https://stripe.com/docs/payments/payment-intents/authentication
      impact: |
        - Balances security with customer friction
        - Reduces drop-offs while staying compliant
        - Supports dynamic fraud and region control
      code_examples:
        # JavaScript — COMPLIANT: 3DS behavior explicitly configured
        - compliant: |
            // Automatic 3DS handling
            await stripe.paymentIntents.create({
              amount: 5000,
              currency: 'eur',
              payment_method: paymentMethodId,
              payment_method_options: {
                card: {
                  request_three_d_secure: 'automatic',
                },
              },
              confirm: true,
            });

            // Force 3DS for high-risk payment
            await stripe.paymentIntents.create({
              amount: 7000,
              currency: 'eur',
              payment_method: paymentMethodId,
              payment_method_options: {
                card: {
                  request_three_d_secure: 'any',
                },
              },
              confirm: true,
            });

        # JavaScript — NON-COMPLIANT: 3DS behavior left to default with no visibility
        - non_compliant: |
            // No 3DS configuration; defaults applied without explicit control
            await stripe.paymentIntents.create({
              amount: 5000,
              currency: 'eur',
              payment_method: paymentMethodId,
              confirm: true,
            });

    - title: "Enforce SCA Based on Customer Region"
      severity: High
      required_context: Regional Compliance, Regulatory Adaptation
      software_version: all
      description: |
        Enforce Strong Customer Authentication (SCA) using 3D Secure for customers in the EEA and UK by setting `payment_method_options.card.request_three_d_secure` during payment creation.
      impact: |
        - Ensures compliance with EEA/UK payment regulations  
        - Reduces declined payments from SCA enforcement gaps  
        - Improves customer trust through secure authentication practices  
      reference_link:
        - https://stripe.com/docs/strong-customer-authentication
      code_examples:
        # JavaScript — COMPLIANT: SCA enforced with 3DS in EEA region
        - compliant: |
            const paymentIntent = await stripe.paymentIntents.create({
              amount: 1000,
              currency: 'eur',  // EEA currency triggers SCA
              payment_method: paymentMethodId,
              payment_method_options: {
                card: {
                  request_three_d_secure: 'any',  // Explicit SCA enforcement
                },
              },
              confirm: true
            });

        # JavaScript — NON-COMPLIANT: Missing 3DS enforcement in EEA region
        - non_compliant: |
            // Fails to set 3D Secure requirement in EEA
            const paymentIntent = await stripe.paymentIntents.create({
              amount: 1000,
              currency: 'eur',  // EEA region triggers SCA rules
              payment_method: paymentMethodId,
              confirm: true
            });

    - title: "Use Dynamic 3DS Logic to Improve Conversion"
      severity: Medium
      required_context: 3D Secure Optimization, Conversion Monitoring
      software_version: all
      description: |
        Use dynamic 3D Secure logic (`request_three_d_secure: 'automatic'`) to apply 3DS challenges only when required by the issuer or regulations.
      impact: |
        - Reduces unnecessary customer friction during checkout  
        - Improves conversion while still meeting SCA requirements  
        - Optimizes authentication without hard-coding 3DS enforcement  
      reference_link:
        - https://stripe.com/docs/payments/3d-secure
      code_examples:
        # JavaScript — COMPLIANT: Uses automatic 3DS logic
        - compliant: |
            const paymentIntent = await stripe.paymentIntents.create({
              amount: 1200,
              currency: 'eur',
              payment_method_types: ['card'],
              payment_method_options: {
                card: {
                  request_three_d_secure: 'automatic'
                }
              },
              confirm: true
            });

        # JavaScript — NON-COMPLIANT: Forces 3DS unnecessarily using 'always'
        - non_compliant: |
            const paymentIntent = await stripe.paymentIntents.create({
              amount: 1200,
              currency: 'eur',
              payment_method_types: ['card'],
              payment_method_options: {
                card: {
                  request_three_d_secure: 'always'
                }
              },
              confirm: true
            });

    - title: "Track 3DS Outcomes via Webhooks"
      severity: Medium
      required_context: 3D Secure Optimization, Conversion Monitoring
      software_version: all
      description: |
        Use Stripe webhooks such as `payment_intent.succeeded` and `payment_intent.requires_action` to handle 3DS authentication outcomes.
      impact: |
        - Enables analysis of 3DS success vs failure rates
        - Supports dynamic retry or fallback flows
        - Helps identify poor-performing issuers or friction points
      reference_link:
        - https://stripe.com/docs/payments/3d-secure
      code_examples:
        # JavaScript — COMPLIANT: Webhook handler tracks 3DS outcomes
        - compliant: |
            app.post('/webhook', (req, res) => {
              const event = parseStripeWebhook(req);
              switch (event.type) {
                case 'payment_intent.succeeded':
                  record3DSStatus(event.data.object, 'success');
                  break;
                case 'payment_intent.requires_action':
                  record3DSStatus(event.data.object, 'challenge_required');
                  break;
              }
              res.sendStatus(200);
            });

        # JavaScript — NON-COMPLIANT: No 3DS-specific event tracking
        - non_compliant: |
            app.post('/webhook', (req, res) => {
              const event = parseStripeWebhook(req);
              // Only logs events generically
              console.log('Event received:', event.type);
              res.sendStatus(200);
            });

    - title: "Pin Stripe API Versions to Avoid Breaking Changes"
      severity: Medium
      required_context: SDK Maintenance, SCA Compliance
      software_version: all
      description: |
        Explicitly set the `apiVersion` when initializing Stripe SDKs.
      impact: |
        - Prevents breaking changes caused by automatic API version updates
        - Improves stability of integration during Stripe upgrades
        - Enables predictable testing and rollout of new features
      reference_link:
        - https://stripe.com/docs/upgrades
      code_examples:
        # JavaScript — COMPLIANT: API version explicitly pinned
        - compliant: |
            const stripe = require('stripe')('sk_test_...', {
              apiVersion: '2024-06-01'
            });

        # JavaScript — NON-COMPLIANT: Relies on default API version
        - non_compliant: |
            const stripe = require('stripe')('sk_test_...');  // No apiVersion specified

    - title: "Use Supported Stripe SDK Versions"
      severity: Medium
      required_context: SDK Maintenance, SCA Compliance
      software_version: all
      description: |
        Use Stripe SDK version 12.0.0 or higher.
      impact: |
        - Avoids deprecated functionality that may cause errors
        - Ensures latest performance and security improvements
        - Maintains support for newly released features and payment methods
      reference_link:
        - https://stripe.com/docs/upgrades
      code_examples:
        # JavaScript — COMPLIANT: Uses supported SDK version (v12.0.0 or higher)
        - compliant: |
            import { loadStripe } from '@stripe/stripe-js';

            const stripe = await loadStripe('pk_test_...');

            // package.json
            {
              "dependencies": {
                "stripe": "^12.0.0"
              }
            }

        # JavaScript — NON-COMPLIANT: Uses outdated SDK version with deprecated methods
        - non_compliant: |
            const stripe = require('stripe')('sk_test_...');

            // This method signature is deprecated in v6
            stripe.charges.create({
              amount: 2000,
              currency: 'usd',
              source: 'tok_visa',
              description: 'Charge for test@example.com',
            });

            // package.json
            {
              "dependencies": {
                "stripe": "^6.0.0"
              }
            }

  - name: "Fraud Prevention with Radar & Machine Learning (ML) Rules"
    paths:
      - '**/payments/**/*.js'
      - '**/payments/**/*.ts'
      - '**/stripe/**/*.js'
      - '**/stripe/**/*.ts'
      - '**/checkout/**/*.js'
      - '**/checkout/**/*.ts'
      - '**/fraud/**/*.js'
      - '**/fraud/**/*.ts'
      - '**/webhooks/**/*.js'
      - '**/webhooks/**/*.ts'
      - '**/api/stripe/**/*.py'
      - '**/api/payments/**/*.py'
      - '**/api/fraud/**/*.py'
      - '**/server/stripe/**/*.js'
      - '**/utils/stripe*.{js,ts}'
    policies:
    - title: "Use Radar's Machine Learning (ML) Scoring"
      description: |
        Apply Stripe Radar's ML-generated `risk_score` and `risk_level` signals when defining custom fraud detection rules:

        - Use `risk_score` thresholds to trigger reviews or blocks.
        - Use `risk_level` values (`normal`, `elevated`, `highest`) to take immediate action.
        - Combine ML signals with contextual data (e.g., location, amount) for layered rules.

      software_version: all
      reference_link:
        - https://stripe.com/docs/radar/machine-learning
      required_context: Fraud Prevention, Radar for Fraud Teams
      severity: High
      impact: |
        - Improves fraud prediction accuracy
        - Reduces manual workload for low-risk payments
        - Enhances adaptability to new fraud trends
      code_examples:
        # language: javascript
        - compliant: |
            // JavaScript — COMPLIANT: Using risk_score and risk_level in custom rules

            // Review transactions with medium-high risk score
            if (risk_score > 65) {
              action = "review";
            }

            // Block transactions flagged as highest risk
            if (risk_level === "highest") {
              action = "block";
            }

            // Layered rule: Combine ML score with IP country
            if (risk_score > 60 && ip_country === "RU") {
              action = "review";
            }
        - non_compliant: |
            // JavaScript — NON-COMPLIANT: ML signals unused or ignored

            // Logs risk_score but takes no action
            console.log(`Transaction risk score: ${risk_score}`);

            // No fraud rules based on ML signals
            const decision = "approve";

    - title: "Route Borderline-Risk Payments to Manual Review"
      severity: Medium
      required_context: Radar Rules, Fraud Review Process
      software_version: all
      reference_link:
        - https://stripe.com/docs/radar/reviews
      description: |
        Use Stripe Radar rules to route transactions with borderline risk scores (e.g., 60–70) for manual review instead of automatically blocking.
      impact: |
        - Avoids false positives from auto-blocking borderline-risk users
        - Allows risk teams to investigate suspicious but uncertain cases
        - Maintains conversion rates for legitimate users
      code_examples:
        # JavaScript — COMPLIANT: Routes borderline-risk scores to manual review
        - compliant: |
            // Example using Stripe Radar custom rules (via Dashboard or API)
            const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);

            // This code would typically be applied via Radar rule creation, but we simulate the logic here:
            function evaluateRiskAction(risk_score) {
              if (risk_score > 60 && risk_score <= 70) {
                return 'review'; // Route to manual review
              } else if (risk_score > 70) {
                return 'block';  // High risk, auto-block
              }
              return 'allow';     // Low risk, allow payment
            }

        # JavaScript — NON-COMPLIANT: Blocks all payments above 60, even borderline-risk
        - non_compliant: |
            const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);

            function evaluateRiskAction(risk_score) {
              if (risk_score > 60) {
                return 'block';  // Too aggressive: blocks borderline-risk transactions
              }
              return 'allow';
            }

    - title: "Avoid Blanket Blocking Below High-Risk Thresholds"
      description: |
        Do not block transactions with low-to-moderate risk scores by default.  
        Reserve auto-blocking for clearly high-risk patterns (e.g. `risk_score > 80`).  
        Use manual review or layered logic for scores in uncertain zones.
      software_version: all
      reference_link:
        - https://stripe.com/docs/radar/radar-rules
      required_context: Radar Rules, Risk Threshold Design
      severity: Medium
      impact: |
        - Avoids revenue loss from overly strict fraud controls
        - Encourages flexible and adaptable fraud defense logic
        - Reduces support cases from legitimate blocked users
      code_examples:
        # JavaScript — COMPLIANT: Reserved blocking only for very high risk
        - compliant: |
            if (risk_score > 80) {
              action = "block";
            } else if (risk_score > 60) {
              action = "review";
            }

        # JavaScript — NON-COMPLIANT: Blanket blocks on moderate risk
        - non_compliant: |
            if (risk_score > 60) {
              action = "block";
            }

    - title: "Restrict Review Queue Access by Role"
      severity: Medium
      required_context: Role Management, Review Workflow
      software_version: all
      reference_link:
        - https://stripe.com/docs/radar/reviews
      description: |
        Access to the manual review queue and review actions must be restricted based on roles defined in the source code.
      impact: |
        - Prevents accidental or malicious fraud approvals
        - Ensures separation of duties in fraud handling
        - Supports audit and compliance requirements
      code_examples:
        # JavaScript — COMPLIANT: Applies role-based check before showing review actions
        - compliant: |
            if (user.role === 'review_manager' && payment.status === 'review') {
              showReviewActions(payment);
            }

        # JavaScript — NON-COMPLIANT: No access control for review actions
        - non_compliant: |
            showReviewActions(payment);

    - title: "Log Manual Review Decisions for Auditability"
      severity: Medium
      required_context: Fraud Review Operations, Logging Strategy
      software_version: all
      reference_link:
        - https://stripe.com/docs/radar/reviews
      description: |
        Manual review actions must call a logging function with structured metadata, including reviewer identity, action type, justification, and timestamp parameters.
      impact: |
        - Supports audit and compliance
        - Helps diagnose false positives or missed fraud
        - Enables continuous improvement of fraud logic
      code_examples:
        # JavaScript — COMPLIANT: Calls structured logging with required parameters
        - compliant: |
            logReviewAction({
              payment_id: payment.id,
              reviewer: currentUser.email,
              action: 'approved',
              reason: 'Verified billing info',
              timestamp: Date.now()
            });

        # JavaScript — NON-COMPLIANT: Takes manual review action without logging
        - non_compliant: |
            approvePayment(payment.id);

    - title: "Trigger Alerts for Flagged Payments"
      severity: Medium
      required_context: Fraud Detection Workflow, Admin Alerting
      software_version: all
      reference_link:
        - https://stripe.com/docs/radar/reviews
      description: |
        Backend code must trigger programmatic alerts when a payment enters manual review status.
      impact: |
        - Enables real-time response to potential fraud
        - Reduces time to review high-risk payments
        - Improves operational awareness across teams
      code_examples:
        # JavaScript — COMPLIANT: Sends an alert when a payment enters review status
        - compliant: |
            if (payment.status === 'review') {
              sendSlackAlert({
                channel: '#fraud-review',
                text: `Flagged payment\nCustomer: ${payment.customer_email}\nAmount: $${payment.amount / 100}\nRisk Score: ${payment.radar_risk_score}`
              });
            }

        # JavaScript — NON-COMPLIANT: No alert triggered for flagged payment
        - non_compliant: |
            if (payment.status === 'review') {
              markAsPending();  // No alert sent
            }

    - title: "Implement Structured Logging for Radar Rule Outcomes"
      description: |
        Implement structured logging for fraud detection decisions involving Stripe Radar rules.  
        Logs should capture rule ID, decision type, outcome classification, and timestamp.  
        Apply the same logging format consistently in all fraud decision paths.
      software_version: all
      reference_link:
        - https://stripe.com/docs/radar/radar-rules
      required_context: Radar Rule Evaluation Logic, Logging Strategy
      severity: Medium
      impact: |
        - Enables downstream analysis of rule performance from application logs
        - Supports auditability of fraud-related decisions
        - Lays foundation for alerting and BI integration without requiring it
      code_examples:
        # JavaScript — COMPLIANT: Logs rule decision with required metadata
        - compliant: |
            // JavaScript — COMPLIANT: Structured logging for Radar rule decision
            logRadarRuleOutcome({
              rule_id: 'rule_large_txn',
              decision: 'review',
              outcome: 'true_positive',
              timestamp: Date.now()
            });

        # JavaScript — NON-COMPLIANT: Missing structured metadata in log
        - non_compliant: |
            // JavaScript — NON-COMPLIANT: Logs vague message without required metadata
            if (payment.amount > 10000) {
              sendToReview(payment);
              console.log("Large transaction sent to review.");  // Missing rule_id, decision, outcome, timestamp
            }

    - title: "Pause Fulfillment Based on Radar Fraud Status"
      severity: High
      required_context: Order Fulfillment, Fraud Decision Handling
      software_version: all
      reference_link:
        - https://stripe.com/docs/radar/reviews
      description: |
        Order fulfillment logic must pause or cancel fulfillment if the Stripe Radar fraud status is `fraudulent`, `blocked`, or under `review`.
      impact: |
        - Prevents shipping fraudulent orders
        - Reduces chargebacks and inventory loss
        - Helps ensure fraud mitigation before shipping
      code_examples:
        # JavaScript — COMPLIANT: Prevent fulfillment if payment is marked fraudulent
        - compliant: |
            if (payment.fraud_details?.stripe_report === 'fraudulent') {
              haltOrder(orderId);
            }

        # JavaScript — NON-COMPLIANT: Ignores fraud status and fulfills order
        - non_compliant: |
            if (payment.status === 'succeeded') {
              fulfillOrder(orderId);  // Ignores Radar fraud status
            }

    - title: "Update Order State from Radar Webhook Events"
      severity: Medium
      required_context: Webhook Integration, Order State Management
      software_version: all
      reference_link:
        - https://stripe.com/docs/radar/reviews
      description: |
        Integrate Stripe Radar webhook events such as `review.opened` and `review.closed` to programmatically update internal order states.
      impact: |
        - Improves fraud visibility for internal systems
        - Keeps order states consistent with payment reviews
        - Enables automated processing upon resolution
      code_examples:
        # JavaScript — COMPLIANT: Uses Radar review events to update order state
        - compliant: |
            app.post('/webhook', async (req, res) => {
              const event = req.body;

              if (event.type === 'payment_intent.review_opened') {
                markOrderAsPendingReview(event.data.object.id);
              }

              if (event.type === 'review.closed' && event.data.object.reason === 'approved') {
                markOrderAsReadyToShip(event.data.object.payment_intent);
              }

              res.status(200).send();
            });

        # JavaScript — NON-COMPLIANT: No order state update based on Radar review events
        - non_compliant: |
            app.post('/webhook', async (req, res) => {
              const event = req.body;
              // No logic for handling review events
              res.status(200).send();
            });

    - title: "Expose Programmatic Controls for Fraud Override"
      severity: Medium
      required_context: Support Tooling, Fraud Flag Handling
      software_version: all
      reference_link:
        - https://stripe.com/docs/radar
      description: |
        Internal tools must conditionally display override options when a payment is flagged as `fraudulent` by Stripe Radar.  
        Override actions must be logged in source code for auditability.
      impact: |
        - Enables timely resolution of false positives
        - Supports structured fraud handling workflows
        - Allows manual escalation with internal accountability
      code_examples:
        # JavaScript — COMPLIANT: Shows override control when payment is flagged and logs outcome
        - compliant: |
            if (payment.fraud_details?.stripe_report === 'fraudulent') {
              showSupportOverrideOption(payment.id);
            }

            // Logs override outcome for auditing
            logFraudReviewResult({
              payment_id: payment.id,
              outcome: 'false_positive',
              reviewed_by: currentUser.id,
              timestamp: Date.now()
            });

        # JavaScript — NON-COMPLIANT: Ignores fraud status and provides no override path
        - non_compliant: |
            renderSupportView({
              userId: currentUser.id,
              paymentId: payment.id
            });  // No fraud override logic or audit logging

    - title: "Trigger 3D Secure Dynamically Based on Risk"
      description: |
        Use dynamic 3D Secure (3DS) configuration to selectively enforce authentication only on higher-risk transactions.  
        Decisions should be based on fraud signals such as Radar risk score, geolocation mismatches, or abnormal behavior patterns.
      software_version: all
      reference_link:
        - https://stripe.com/docs/payments/3d-secure
      required_context: 3D Secure Configuration, Fraud Detection Rules
      severity: Medium
      impact: |
        - Strengthens fraud protection where needed
        - Avoids unnecessary friction for low-risk users
        - Balances conversion and security effectively
      code_examples:
        # JavaScript — COMPLIANT: 3DS triggered only when risk indicators are high
        - compliant: |
            // JavaScript — COMPLIANT: Set 3DS dynamically using 'automatic' in PaymentIntent
            const paymentIntent = await stripe.paymentIntents.create({
              amount: 5000,
              currency: 'usd',
              payment_method_types: ['card'],
              payment_method_options: {
                card: {
                  request_three_d_secure: 'automatic' // Stripe uses risk signals to decide
                }
              },
              metadata: {
                user_id: user.id
              }
            });

        # JavaScript — NON-COMPLIANT: Forces 3DS for all payments, ignoring risk
        - non_compliant: |
            // JavaScript — NON-COMPLIANT: Forces 3DS even for low-risk users
            const paymentIntent = await stripe.paymentIntents.create({
              amount: 5000,
              currency: 'usd',
              payment_method_types: ['card'],
              payment_method_options: {
                card: {
                  request_three_d_secure: 'any' // Forces challenge even if low risk
                }
              },
              metadata: {
                user_id: user.id
              }
            });

  - name: "Logging, Monitoring & Alerting"
    paths:
      - '**/logging/**/*'
      - '**/monitoring/**/*'
      - '**/alerts/**/*'
      - '**/logs/**/*'
      - '**/loggers/**/*'
      - '**/*.log'
      - '**/sentry/**/*'
      - '**/datadog/**/*'
      - '**/newrelic/**/*'
      - '**/prometheus/**/*'
      - '**/grafana/**/*'
      - '**/cloudwatch/**/*'
      - '**/alerting/**/*'
      - '**/healthchecks/**/*'
      - '**/observability/**/*'
      - '**/metrics/**/*'
      - '**/telemetry/**/*'
      - '**/instrumentation/**/*'
    policies:
    - title: "Log Stripe Request ID for Traceability"
      description: |
        Log the `request-id` from Stripe API responses. Use Stripe SDK features such as `lastResponse.headers` to extract this identifier.
      software_version: all
      reference_link:
        - https://stripe.com/docs/api/request_ids
      required_context: Logging, Monitoring & Stripe Integration
      severity: Medium
      impact: |
        - Enables cross-system debugging of payment issues
        - Supports correlation with Stripe logs and observability platforms
        - Improves support interactions by providing traceable identifiers
      code_examples:
        # JavaScript — COMPLIANT: Logs Stripe request-id using SDK response header
        - compliant: |
            const stripe = require('stripe')(STRIPE_SECRET_KEY);

            const paymentIntent = await stripe.paymentIntents.create({
              amount: 1000,
              currency: 'usd'
            });

            const requestId = paymentIntent.lastResponse.headers['request-id'];
            logger.info('Stripe PaymentIntent created', {
              requestId,
              transactionId: paymentIntent.id,
              userId: currentUser.id,
              timestamp: new Date().toISOString()
            });

        # JavaScript — NON-COMPLIANT: Omits request-id from log output
        - non_compliant: |
            const stripe = require('stripe')(STRIPE_SECRET_KEY);

            const paymentIntent = await stripe.paymentIntents.create({
              amount: 1000,
              currency: 'usd'
            });

            logger.info('PaymentIntent created', {
              transactionId: paymentIntent.id
            });

    - title: "Log Minimal Metadata from Webhook Events"
      description: |
        Log only essential metadata from Stripe webhook payloads such as event type, ID, timestamp, and object ID. Avoid logging full event bodies or sensitive information.
      software_version: all
      reference_link:
        - https://stripe.com/docs/webhooks
      required_context: Webhook Handling, Compliance Logging
      severity: Medium
      impact: |
        - Maintains compliance with PCI, GDPR, and SOC2
        - Prevents accidental exposure of sensitive data
        - Enables secure and effective audit trails for webhook activity
        - Structured logging and source labeling further enhance traceability
      code_examples:
        # JavaScript — COMPLIANT: Logs minimal Stripe webhook event metadata only
        - compliant: |
            app.post('/webhook', express.json(), (req, res) => {
              const event = req.body;

              logger.info('Received Stripe webhook', {
                source: 'stripe-webhook',
                eventId: event.id,
                eventType: event.type,
                created: event.created,
                objectId: event.data?.object?.id
              });

              res.status(200).send();
            });

        # JavaScript — NON-COMPLIANT: Logs full payload including sensitive data
        - non_compliant: |
            app.post('/webhook', express.json(), (req, res) => {
              const event = req.body;

              // Logs entire payload including PII
              logger.info('Webhook received', { event });

              res.status(200).send();
            });

    - title: "Log Structured Stripe API Errors"
      description: |
        Log Stripe API errors using a structured format that includes error type, code, status, and request ID.
      software_version: all
      reference_link:
        - https://stripe.com/docs/error-codes
      required_context: API Integration, Payment Reliability
      severity: Medium
      impact: |
        - Simplifies debugging by providing clear error context
        - Enables downstream tooling to categorize and analyze issues
        - Enhances visibility into payment reliability
      code_examples:
        # JavaScript — COMPLIANT: Logs structured error data including context
        - compliant: |
            const stripe = require('stripe')(STRIPE_SECRET_KEY);

            try {
              const paymentIntent = await stripe.paymentIntents.create({
                amount: 1000,
                currency: 'usd',
                payment_method: 'pm_card_visa',
                confirm: true
              });
            } catch (err) {
              logger.error('Stripe error', {
                type: err.type,
                code: err.code,
                decline_code: err.decline_code,
                statusCode: err.statusCode,
                requestId: err.requestId,
                userId: currentUser.id
              });
            }

        # JavaScript — NON-COMPLIANT: Logs raw error without structure or context
        - non_compliant: |
            try {
              const paymentIntent = await stripe.paymentIntents.create({ ... });
            } catch (err) {
              console.error(err); // No structured logging
            }

    - title: "Implement Threshold-Based Alerting for Payment Failures"
      severity: High
      required_context: Payment Error Handling, Alerting Logic
      software_version: all
      reference_link:
        - https://stripe.com/docs/monitoring
      description: |
        Application code must evaluate whether payment failure counts exceed a defined threshold and invoke an alert service when that threshold is crossed.
      impact: |
        - Enables proactive incident response
        - Improves observability into payment reliability
        - Helps surface regressions or outages
      code_examples:
        # JavaScript — COMPLIANT: Sends alert when payment failures exceed threshold
        - compliant: |
            if (paymentFailures > failureThreshold) {
              alertService.send({
                message: "Spike in payment failures detected",
                severity: "high",
                context: { count: paymentFailures, threshold: failureThreshold }
              });
            }

        # JavaScript — NON-COMPLIANT: Logs failure but lacks alerting logic
        - non_compliant: |
            console.log("Payment failed");  // No alert or threshold check

    - title: "Implement Robust Error Handling in Webhook Endpoints"
      severity: Medium
      required_context: Webhook Endpoint Logic, Stripe Event Handling
      software_version: all
      reference_link:
        - https://stripe.com/docs/webhooks
      description: |
        Webhook endpoint code must include logic to handle errors gracefully, log failures, and return appropriate HTTP status codes to prevent unnecessary retries.
      impact: |
        - Improves webhook delivery reliability
        - Reduces unnecessary retry attempts from Stripe
        - Helps diagnose delivery issues via logs
      code_examples:
        # JavaScript — COMPLIANT: Handles webhook errors and returns 2xx/4xx status
        - compliant: |
            app.post('/webhook', async (req, res) => {
              try {
                const event = stripe.webhooks.constructEvent(req.body, req.headers['stripe-signature'], webhookSecret);
                handleStripeEvent(event);
                res.status(200).send(); // ACK success
              } catch (err) {
                console.error("Webhook error:", err);
                res.status(400).send(`Webhook Error: ${err.message}`); // Prevents retry on bad signature
              }
            });

        # JavaScript — NON-COMPLIANT: Fails silently without status code
        - non_compliant: |
            app.post('/webhook', async (req, res) => {
              const event = JSON.parse(req.body); // No signature check
              handleStripeEvent(event);           // No error handling
            });

    - title: "Include Conditional Alerting Logic for Payment Success Tracking"
      severity: High
      required_context: Payment Flow Monitoring, Success Path Implementation
      software_version: all
      reference_link:
        - https://stripe.com/docs/payments
      description: |
        Payment flow code must include conditional logic that integrates with an alerting mechanism when success indicators fall outside expected ranges.
      impact: |
        - Encourages use of structured observability in payment code
        - Makes anomalies in success tracking detectable through static review
        - Prevents silent failure of payment logic
      code_examples:
        # JavaScript — COMPLIANT: Uses alert service with conditional success check
        - compliant: |
            const successRate = totalSuccesses / totalAttempts;
            if (successRate < 0.95) {
              alertService.send({
                message: "Payment success rate below acceptable threshold",
                severity: "high",
                metadata: { successRate }
              });
            }

        # JavaScript — NON-COMPLIANT: Tracks success but does not surface anomalies
        - non_compliant: |
            const successRate = totalSuccesses / totalAttempts;
            console.log("Success rate:", successRate); // No alert, just log

    - title: "Tag Alerts with Severity and Trace Data"
      description: |
        Include severity levels and contextual trace data (e.g., metric value, thresholds, timestamps) in all monitoring alerts.
      software_version: all
      reference_link:
        - https://stripe.com/docs/monitoring
      required_context: Alerting Systems, Observability Design
      severity: Medium
      impact: |
        - Improves alert clarity and urgency prioritization
        - Speeds up root cause analysis
        - Facilitates integration with monitoring platforms
      code_examples:
        # JavaScript — COMPLIANT: Alert includes severity and trace context
        - compliant: |
            alertService.send({
              message: "Spike in payment failures",
              severity: "high",
              context: { count: 32, threshold: 10, timestamp: Date.now() }
            });
        # JavaScript — NON-COMPLIANT: Alert missing severity or trace info
        - non_compliant: |
            alertService.send("Something is wrong"); // Unstructured

    - title: "Emit Structured Logs and Metrics for Stripe Events"
      severity: Medium
      required_context: Stripe Event Handling, Logging and Metrics Code
      software_version: all
      reference_link:
        - https://stripe.com/docs/logs
      description: |
        Stripe event handlers should emit structured logs and metrics using clearly named keys and Stripe event identifiers.
      impact: |
        - Improves traceability of payment events
        - Makes Stripe-related flows auditable through code-level review
        - Enables consistent instrumentation without requiring external observability platforms
      code_examples:
        # JavaScript — COMPLIANT: Structured log and metric emitted for Stripe event
        - compliant: |
            logger.info({
              event: "payment_intent.succeeded",
              stripe_event_id: event.id,
              status: "success"
            });

            metrics.increment("stripe.payment_success");

        # JavaScript — NON-COMPLIANT: Logs unstructured message without event context
        - non_compliant: |
            console.log("Stripe event received"); // No structure, no metrics

    - title: "Use Structured Logs with Consistent Fields"
      description: |
        Emit structured logs in a consistent format, including fields such as `customer_id`, `order_id`, `stripe_event_id`, and `environment`.
      software_version: all
      reference_link:
        - https://stripe.com/docs/logs
      required_context: Structured Logging, Payment Event Processing
      severity: Medium
      impact: |
        - Improves log searchability and filtering
        - Enables correlation between systems
        - Facilitates debugging and traceability
      code_examples:
        # JavaScript — COMPLIANT: Structured log with standard fields
        - compliant: |
            console.log(JSON.stringify({
              event_type: "payment_intent.succeeded",
              stripe_event_id: event.id,
              customer_id: customerId,
              order_id: orderId,
              environment: process.env.NODE_ENV,
              timestamp: new Date().toISOString()
            }));
        # JavaScript — NON-COMPLIANT: Unstructured log format
        - non_compliant: |
            console.log("Payment success: " + customerId);

    - title: "Instrument Stripe Webhook and Payment Handlers"
      severity: Medium
      required_context: Metric Instrumentation, Stripe Webhook Logic
      software_version: all
      reference_link:
        - https://stripe.com/docs/logs
      description: |
        Stripe webhook and payment handlers must include metric instrumentation using in-code observability primitives such as timers, counters, and labels.
      impact: |
        - Ensures visibility into webhook execution latency and success rates
        - Supports consistent instrumentation of payment flows
        - Enables future integration with alerting or monitoring tools
      code_examples:
        # JavaScript — COMPLIANT: Captures metrics using observability library
        - compliant: |
            metrics.observe("stripe.webhook.latency", responseTime, {
              route: "/webhook",
              status: "success"
            });

            metrics.increment("stripe.payment.success");

        # JavaScript — NON-COMPLIANT: No metric instrumentation
        - non_compliant: |
            // Only logs outcome, doesn't emit metrics
            console.log("Webhook handled");

    - title: "Apply Tags and Labels in Logs and Metrics"
      description: |
        Tag all emitted logs and metrics with attributes like `environment`, `severity`, `region`, or `component`.
      software_version: all
      reference_link:
        - https://docs.datadoghq.com/tagging/
      required_context: Monitoring Infrastructure, Logging Standards
      severity: Medium
      impact: |
        - Enables efficient filtering and dashboarding
        - Improves incident triage and alert routing
        - Supports multi-environment or multi-tenant systems
      code_examples:
        # JavaScript — COMPLIANT: Adds labels and tags to metrics
        - compliant: |
            metrics.observe("stripe.webhook.latency", responseTime, {
              route: "/webhook",
              environment: process.env.NODE_ENV,
              severity: "info"
            });
        # JavaScript — NON-COMPLIANT: Missing tags or metadata
        - non_compliant: |
            metrics.observe("stripe.webhook.latency", responseTime); // No context tags

    - title: "Log Structured Reviewer Decision Events"
      description: |
        Use structured logging to record decision events, including reviewer ID, decision type, reason, and associated payment identifiers.
      software_version: all
      reference_link:
        - https://stripe.com/docs/radar/manual-review
      required_context: Compliance, Internal Controls
      severity: Medium
      impact: |
        - Ensures accountability for decision actions
        - Enables post-event analysis and auditing
        - Satisfies internal fraud and compliance reporting
      code_examples:
        # JavaScript — COMPLIANT: Logs all required reviewer decision fields
        - compliant: |
            auditLogger.log({
              action: 'manual_review_decision',
              payment_intent_id: 'pi_123',
              reviewer_id: 'user_456',
              decision: 'approved',
              reason: 'Customer verified via support call',
              timestamp: new Date().toISOString()
            });
        # JavaScript — NON-COMPLIANT: Reviewer decision not logged
        - non_compliant: |
            approvePaymentIntent('pi_123');

    - title: "Use Structured Logging with Metadata for Review Events"
      description: |
        Use structured logs when recording Stripe manual review decisions. Include metadata such as reviewer ID, payment intent ID, reason, and timestamp.
      software_version: all
      reference_link:
        - https://stripe.com/docs/radar/manual-review
      required_context: Logging Standards, Security Auditing
      severity: Medium
      impact: |
        - Supports traceability in audit trails
        - Improves log parsing and filtering in observability tools
        - Enables accurate forensic and compliance analysis
      code_examples:
        # JavaScript — COMPLIANT: Structured log format with key metadata
        - compliant: |
            console.log(JSON.stringify({
              event: 'manual_review_decision',
              reviewer_id: 'user_456',
              payment_intent_id: 'pi_123',
              decision: 'declined',
              reason: 'Suspicious behavior detected',
              timestamp: new Date().toISOString()
            }));
        # JavaScript — NON-COMPLIANT: Unstructured log with no metadata
        - non_compliant: |
            console.log("Manual review approved");

    - title: "Redact Sensitive Fields from Stripe-Related Logs"
      description: |
        Automatically redact sensitive information such as card number, CVC, IP addresses, and email before logging any Stripe-related data.
      software_version: all
      reference_link:
        - https://stripe.com/docs/security/stripe
      required_context: Logging, Compliance
      severity: Medium
      impact: |
        - Reduces risk of PII or PCI data leaks
        - Helps meet compliance requirements (e.g., PCI-DSS, GDPR)
        - Makes logs safe for shared environments
      code_examples:
        # JavaScript — COMPLIANT: Redacting sensitive fields before logging
        - compliant: |
            const logPayload = {
              email: maskEmail(customer.email),  // j***@domain.com
              address: '[REDACTED]',
              card_last4: '4242',
              cvc: '[REDACTED]',
              amount: 5000
            };
            logger.info('Processed payment', logPayload);
        # JavaScript — NON-COMPLIANT: Logging raw sensitive data
        - non_compliant: |
            logger.info('Payment details', {
              email: 'user@example.com',
              card_number: '4242 4242 4242 4242',
              cvc: '123'
            });

    - title: "Use Allowlist-Based Logging for Stripe Events"
      description: |
        Restrict log output to only include explicitly approved fields from Stripe event payloads using an allowlist approach.
      software_version: all
      reference_link:
        - https://stripe.com/docs/security/stripe
      required_context: Secure Logging Practices
      severity: Medium
      impact: |
        - Prevents accidental logging of sensitive or unnecessary data
        - Enables safer long-term storage and analysis
        - Helps with log consistency and review
      code_examples:
        # JavaScript — COMPLIANT: Only logging allowed fields
        - compliant: |
            const safeFields = pick(webhookData, ['payment_intent_id', 'status', 'amount']);
            logger.info('Stripe event', safeFields);
        # JavaScript — NON-COMPLIANT: Logging full raw webhook payload
        - non_compliant: |
            logger.info('Stripe event', webhookData);

    - title: "Mask or Hash PII Before Logging"
      description: |
        Mask or hash personally identifiable information (PII) such as names, emails, or phone numbers before writing them to logs.
      software_version: all
      reference_link:
        - https://stripe.com/docs/security/stripe
      required_context: Privacy, Logging Standards
      severity: Medium
      impact: |
        - Prevents exposure of sensitive user data
        - Complies with PII handling standards
        - Supports safe debugging and monitoring
      code_examples:
        # JavaScript — COMPLIANT: Masking email before logging
        - compliant: |
            const maskedEmail = maskEmail('user@example.com'); // Output: u***@example.com
            logger.info('Customer login', { email: maskedEmail });
        # JavaScript — NON-COMPLIANT: Logging raw email
        - non_compliant: |
            logger.info('Customer login', { email: 'user@example.com' });

    - title: "Sanitize Sensitive Data Before Logging"
      description: |
        Ensure that sensitive information such as card numbers, CVC codes, access tokens, or email addresses are removed or masked before being written to logs.
      software_version: all
      reference_link:
        - https://stripe.com/docs/security/stripe
      required_context: Logging Standards, Secure Coding Practices
      severity: Medium
      impact: |
        - Prevents accidental exposure of sensitive data
        - Supports compliance with data protection standards
        - Reduces risk of information leaks in log aggregators
      code_examples:
        # JavaScript — COMPLIANT: Sensitive fields sanitized before logging
        - compliant: |
            const sanitizedPayload = {
              ...payload,
              card_number: '[REDACTED]',
              cvc: '[REDACTED]',
              email: maskEmail(payload.email),
            };
            logger.info('Stripe charge processed', sanitizedPayload);
        # JavaScript — NON-COMPLIANT: Sensitive fields logged directly
        - non_compliant: |
            logger.info('Stripe charge processed', payload); // Includes raw sensitive data

  - name: "Testing, Fixtures & Stripe CLI"
    paths:
      - "**/tests/**"
      - "**/__tests__/**"
      - "**/fixtures/**"
      - "**/test_*.py"
      - "**/stripe/**"
      - "**/scripts/stripe-cli/**"
      - "**/*.test.js"
      - "**/*.test.ts"
      - "**/*.spec.js"
      - "**/*.spec.ts"
      - "stripe-cli.yml"
      - ".stripe/**"
    policies:
    - title: "Use Stripe Test API Keys in Non-Production Environments"
      description: |
        Use Stripe test mode API keys (`sk_test_...`, `pk_test_...`) in all non-production environments such as local development, staging, and CI pipelines.
      software_version: all
      reference_link:
        - https://docs.stripe.com/keys
      required_context: Development, Testing, CI/CD Environments
      severity: Low
      impact: |
        - Prevents accidental real transactions during development
        - Avoids triggering live webhooks or fraud detection
        - Enables safe integration testing
      code_examples:
        # JavaScript — COMPLIANT: Using test key via env var
        - compliant: |
            const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY); // process.env contains test key
        # GitHub Actions — COMPLIANT: test key injected securely
        - compliant: |
            env:
              STRIPE_SECRET_KEY: ${{ secrets.STRIPE_TEST_KEY }}
        # JavaScript — NON-COMPLIANT: live key used in dev code
        - non_compliant: |
            const stripe = require('stripe')('sk_live_abc123...');

    - title: "Load Stripe API Keys from Secure Sources (Never Hardcode)"
      description: |
        Always load Stripe API keys from secure environment variables or secret managers. Never hardcode API keys directly in source code or scripts.
      software_version: all
      reference_link:
        - https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions
      required_context: API Key Management, CI/CD, Source Control
      severity: Medium
      impact: |
        - Protects against credential leaks in version control
        - Supports centralized secrets management
        - Enhances DevOps and compliance hygiene
      code_examples:
        # JavaScript — COMPLIANT: Using env variable for key
        - compliant: |
            const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);
        # JavaScript — NON-COMPLIANT: Hardcoded key in file
        - non_compliant: |
            const stripe = require('stripe')('sk_test_hardcoded_key_here');
    
    - title: "Use Declarative Stripe Test Data in Source Code"
      severity: Low
      required_context: Testing, Development
      software_version: all
      reference_link:
        - https://docs.stripe.com/testing
      description: |
        Define reusable and structured test data in source code using mock objects or static fixtures for Stripe API testing. Avoid hardcoding test logic that makes real API calls during test setup.
      impact: |
        - Ensures consistent and reproducible test environments
        - Reduces human error in test setup
        - Supports CI-friendly test automation
      code_examples:
        # JavaScript — COMPLIANT: Declarative test fixture defined in source code
        - compliant: |
            const stripeTestFixture = {
              amount: 2000,
              currency: 'usd',
              description: 'Test payment',
            };

            test('creates a payment intent with mock data', async () => {
              const response = await createPaymentIntent(stripeTestFixture);
              expect(response.amount).toBe(2000);
              expect(response.currency).toBe('usd');
            });

        # JavaScript — NON-COMPLIANT: Makes real Stripe API call during test setup
        - non_compliant: |
            let paymentIntent;

            beforeAll(async () => {
              paymentIntent = await stripe.paymentIntents.create({
                amount: 2000,
                currency: 'usd',
              }); // Real Stripe API call made during test setup
            });

            test('uses real payment intent from setup', async () => {
              expect(paymentIntent.amount).toBe(2000);
            });

    - title: "Use Stripe Test Card Numbers to Simulate Payment Scenarios"
      description: |
        In non-production environments, simulate payment outcomes by using Stripe-provided test card numbers. Do not use live payment methods or real card data in test or staging environments.
      software_version: all
      reference_link:
        - https://docs.stripe.com/testing
      required_context: Testing, Payment Simulation
      severity: Low
      impact: |
        - Enables validation of different payment outcomes
        - Prevents accidental live transactions during testing
        - Improves reliability of payment flow logic in QA
      code_examples:
        # JavaScript — COMPLIANT: Simulate 3DS-required card using Stripe test number
        - compliant: |
            const paymentIntent = await stripe.paymentIntents.create({
              amount: 5000,
              currency: 'usd',
              payment_method_data: {
                type: 'card',
                card: { number: '4000002500003155', exp_month: 12, exp_year: 2025, cvc: '123' }
              },
              confirm: true
            });

            if (paymentIntent.status === 'requires_action') {
              // Handle 3D Secure flow
            }

        # JavaScript — NON-COMPLIANT: Using a live payment method in test environment
        - non_compliant: |
            const paymentIntent = await stripe.paymentIntents.create({
              amount: 5000,
              currency: 'usd',
              payment_method: 'pm_live_card',
              confirm: true
            });

    - title: "Simulate Disputes Using Stripe Test Helpers API"
      description: |
        Use Stripe’s `testHelpers` API to create mock disputes in non-production environments. Do not simulate disputes by manually triggering edge cases or using live API calls.
      software_version: all
      reference_link:
        - https://docs.stripe.com/test-helpers
        - https://docs.stripe.com/disputes
      required_context: Testing, Dispute Simulation
      severity: Low
      impact: |
        - Ensures dispute workflows are testable in CI environments
        - Enables automation of dispute scenarios
        - Prevents accidental testing in production
      code_examples:
        # JavaScript — COMPLIANT: Simulate dispute using testHelpers API
        - compliant: |
            const dispute = await stripe.testHelpers.disputes.create({
              charge: 'ch_3Nk1ZsEaxXXXXX'
            });
            console.log(dispute.status); // e.g., 'needs_response'

        # JavaScript — NON-COMPLIANT: Attempting to test disputes through real API misuse
        - non_compliant: |
            // Triggers a real dispute by intentionally charging a stolen card in test/live
            const charge = await stripe.charges.create({
              amount: 2000,
              currency: 'usd',
              source: 'tok_chargeback', // Triggers dispute in test mode, but not using testHelpers
            });

            // This approach is discouraged as it's not part of testHelpers and can lead to misuse

    - title: "Verify Webhook Signatures in Test Environments"
      description: |
        Use `stripe.webhooks.constructEvent()` to verify webhook signatures when receiving test events via Stripe CLI or test mode webhooks.
      software_version: all
      reference_link:
        - https://docs.stripe.com/webhooks/signatures
        - https://docs.stripe.com/cli/webhooks
      required_context: Testing, Webhook Simulation, Stripe CLI
      severity: Medium
      impact: |
        - Confirms test webhooks are securely processed
        - Aligns local behavior with production verification logic
        - Prevents incorrect assumptions about event authenticity
      code_examples:
        # JavaScript — COMPLIANT: Verifies test webhook using Stripe CLI secret
        - compliant: |
            const endpointSecret = process.env.STRIPE_WEBHOOK_SECRET;

            app.post('/webhook', express.raw({ type: 'application/json' }), (req, res) => {
              const sig = req.headers['stripe-signature'];
              let event;

              try {
                event = stripe.webhooks.constructEvent(req.body, sig, endpointSecret);
              } catch (err) {
                return res.status(400).send(`Webhook Error: ${err.message}`);
              }

              // Handle verified event
              res.status(200).send();
            });

        # JavaScript — NON-COMPLIANT: Does not verify webhook from CLI or test mode
        - non_compliant: |
            app.post('/webhook', express.json(), (req, res) => {
              const event = req.body;
              // No signature check performed
              res.status(200).send();
            });

    - title: "Include Stripe CLI Commands in Test Scripts"
      severity: Medium
      required_context: Local Testing, Automated Scripts, CI/CD Hooks
      software_version: all
      reference_link:
        - https://docs.stripe.com/cli
      description: |
        Ensure test shell scripts or CI/CD setup files include invocations of `stripe trigger` or `stripe fixtures` to simulate events or create test data using the Stripe CLI.
      impact: |
        - Promotes reproducible local and CI testing
        - Encourages consistent test data generation patterns
        - Enables static detection of Stripe CLI test setup
      code_examples:
        # Bash — COMPLIANT: Script includes Stripe CLI trigger and fixture commands
        - compliant: |
            #!/bin/bash

            stripe trigger payment_intent.created
            stripe fixtures create customer --data '[]'

        # Bash — NON-COMPLIANT: Script does not include Stripe CLI commands
        - non_compliant: |
            #!/bin/bash

            echo "Running integration tests"
            npm run test:webhooks

    - title: "Simulate Payment Failures Using Stripe Test Cards"
      description: |
        Use Stripe’s special test card numbers in integration tests to simulate payment failures such as card declines or insufficient funds.
      software_version: all
      reference_link:
        - https://docs.stripe.com/testing#international-cards
      required_context: Integration Testing, Payment Error Handling
      severity: Medium
      impact: |
        - Enables testing of failure scenarios in payment workflows
        - Ensures proper handling of payment rejections
        - Improves application resilience against declined transactions
      code_examples:
        # JavaScript — COMPLIANT: Simulates card_declined scenario using test card
        - compliant: |
            const paymentIntent = await stripe.paymentIntents.create({
              amount: 1000,
              currency: 'usd',
              payment_method_data: {
                type: 'card',
                card: {
                  number: '4000000000000002', // card_declined test card
                  exp_month: 12,
                  exp_year: 2025,
                  cvc: '123'
                }
              },
              confirm: true
            });

            if (paymentIntent.status === 'requires_payment_method') {
              // Prompt user to update payment method
            }

        # JavaScript — NON-COMPLIANT: Uses a passing test card and fails to simulate failure
        - non_compliant: |
            const paymentIntent = await stripe.paymentIntents.create({
              amount: 1000,
              currency: 'usd',
              payment_method_data: {
                type: 'card',
                card: {
                  number: '4242424242424242', // always succeeds
                  exp_month: 12,
                  exp_year: 2025,
                  cvc: '123'
                }
              },
              confirm: true
            });

            if (paymentIntent.status !== 'succeeded') {
              throw new Error("Unexpected failure");
            }

    - title: "Version Stripe Test Fixtures with API Changes"
      description: |
        Always version Stripe test fixture files and align them with the corresponding API version or application release.
      software_version: all
      reference_link:
        - https://docs.stripe.com/testing/stripe-cli/fixtures
      required_context: Test Data Management, Integration Testing, API Versioning
      severity: Medium
      impact: |
        - Prevents test breakage from Stripe API changes
        - Enables traceable changes to test behavior over time
        - Supports long-term test reliability across releases
      code_examples:
        # JavaScript — COMPLIANT: Fixture files are versioned and aligned with API usage
        - compliant: |
            // fixtures/v2025-07-01/products.json
            {
              "products": [
                {
                  "id": "prod_standard",
                  "name": "Standard Plan",
                  "type": "service"
                }
              ]
            }

            // Test runner script
            const { execSync } = require("child_process");
            execSync("stripe fixtures < fixtures/v2025-07-01/products.json");

            // Version is referenced in code
            const FIXTURE_VERSION = "v2025-07-01";
        # JavaScript — NON-COMPLIANT: Unversioned fixture usage and no version tracking
        - non_compliant: |
            // fixtures/products.json
            {
              "products": [
                {
                  "id": "prod_legacy",
                  "name": "Old Plan",
                  "type": "service"
                }
              ]
            }

            // Script uses unversioned fixture directly
            const { execSync } = require("child_process");
            execSync("stripe fixtures < fixtures/products.json");

            // No reference to fixture version or update strategy

  - name: "Performance & Connection Handling"
    paths:
      - "**/api/**"
      - "**/services/**"
      - "**/lib/**"
      - "**/utils/**"
      - "**/network/**"
      - "**/*.js"
      - "**/*.ts"
      - "**/*.py"
    policies:
    - title: "Reuse HTTP/TLS Connections for Stripe API Calls"
      description: |
        Configure HTTP clients or Stripe SDKs to reuse connections across multiple API requests instead of creating a new connection or client per request.

      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: API Performance, Network Optimization
      severity: Medium
      impact: |
        - Reduces API call latency by avoiding TCP/TLS handshake overhead
        - Lowers CPU and memory usage on both client and Stripe servers
        - Improves throughput and scalability of payment integrations
      code_examples:
        # language: javascript
        - compliant: |
            // Node.js example using the Stripe SDK with default keep-alive agent
            const https = require('https');
            const agent = new https.Agent({ keepAlive: true });

            const stripe = require('stripe')('sk_test_...', {
              httpAgent: agent,
            });

            const paymentIntent = await stripe.paymentIntents.create({ amount: 1000, currency: 'usd' });
        - non_compliant: |
            // Creating a new Stripe client or HTTP agent per request (inefficient)
            async function createPayment() {
              const stripe = require('stripe')('sk_test_...');
              return await stripe.paymentIntents.create({ amount: 1000, currency: 'usd' });
            }

    - title: "Use Exponential Backoff with Jitter for Retryable Stripe Errors"
      description: |
        Implement retry logic using exponential backoff with jitter to handle transient Stripe API errors such as 5xx and 429 responses.
      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: API Reliability, Error Handling, Rate Limiting
      severity: Medium
      impact: |
        - Increases resilience to transient failures and rate limits
        - Prevents request storms during high-error periods
        - Improves system stability and API success rates
      code_examples:
        # JavaScript — COMPLIANT: Uses exponential backoff with jitter for retryable errors
        - compliant: |
            async function retryWithBackoff(fn, retries = 5, baseDelay = 500) {
              for (let attempt = 1; attempt <= retries; attempt++) {
                try {
                  return await fn();
                } catch (err) {
                  if (![429, 500, 502, 503, 504].includes(err.statusCode)) {
                    throw err; // Don't retry non-retryable errors
                  }

                  if (attempt === retries) throw err;

                  const backoff = baseDelay * 2 ** (attempt - 1);
                  const jitter = Math.random() * 1000;
                  await new Promise(r => setTimeout(r, backoff + jitter));
                }
              }
            }

            await retryWithBackoff(() => stripe.paymentIntents.create({
              amount: 1000,
              currency: 'usd'
            }));
        # JavaScript — NON-COMPLIANT: Retries indefinitely without backoff or jitter
        - non_compliant: |
            async function retryForever(fn) {
              while (true) {
                try {
                  return await fn();
                } catch {
                  // No delay, no backoff, and retries forever — bad practice
                }
              }
            }

            await retryForever(() => stripe.paymentIntents.create({
              amount: 1000,
              currency: 'usd'
            }));

    - title: "Parallelize Independent Stripe API Read Operations"
      description: |
        Execute multiple independent Stripe API read calls in parallel using asynchronous techniques like `Promise.all`.
      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Performance Optimization, API Efficiency
      severity: Medium
      impact: |
        - Minimizes total response time for dashboards and bulk data views
        - Enhances frontend responsiveness by reducing blocking API calls
        - Improves throughput under high-volume data retrieval scenarios
      code_examples:
        # JavaScript — COMPLIANT: Executes API read operations in parallel
        - compliant: |
            const [products, customers, subscriptions] = await Promise.all([
              stripe.products.list({ limit: 10 }),
              stripe.customers.list({ limit: 10 }),
              stripe.subscriptions.list({ limit: 10 })
            ]);

            // Continue processing once all are ready
            console.log(products.data.length, customers.data.length, subscriptions.data.length);
        
        # JavaScript — NON-COMPLIANT: Executes API read operations sequentially
        - non_compliant: |
            const products = await stripe.products.list({ limit: 10 });
            const customers = await stripe.customers.list({ limit: 10 });
            const subscriptions = await stripe.subscriptions.list({ limit: 10 });

            // Each call waits for the previous to complete — increases latency

    - title: "Respect Stripe Rate Limits to Prevent Service Disruptions"
      description: |
        Implement request throttling by handling Stripe rate limit responses using headers like `Retry-After` and `X-Stripe-Rate-Limit`.
      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: API Rate Limiting, Request Throttling
      severity: Medium
      impact: |
        - Prevents API throttling and service downtime
        - Improves system stability and user experience
        - Enables proactive detection and resolution of performance bottlenecks
      code_examples:
        # JavaScript — COMPLIANT: Handles 429 using Retry-After and exponential backoff
        - compliant: |
            async function makeRequest() {
              try {
                return await stripe.customers.list();
              } catch (err) {
                if (err.statusCode === 429) {
                  const retryAfter = parseInt(err.headers['retry-after'] || '1', 10);
                  await new Promise(r => setTimeout(r, retryAfter * 1000));
                  return makeRequest();
                }
                throw err;
              }
            }

        # JavaScript — NON-COMPLIANT: Ignores rate limits and retry headers
        - non_compliant: |
            async function unsafeRequest() {
              return await stripe.customers.list();
            }

    - title: "Enable HTTP Keep-Alive for Stripe API Calls"
      description: |
        Configure HTTP clients to reuse connections using HTTP keep-alive when communicating with Stripe APIs.
      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: HTTP Client Configuration, Network Efficiency
      severity: Medium
      impact: |
        - Reduces connection overhead and latency
        - Improves efficiency in high-volume applications
      code_examples:
        # JavaScript — COMPLIANT: Uses keep-alive agent with Stripe
        - compliant: |
            const https = require('https');
            const agent = new https.Agent({ keepAlive: true });

            const stripeClient = require('stripe')('sk_test_key', {
              httpAgent: agent
            });
        # JavaScript — NON-COMPLIANT: No keep-alive agent
        - non_compliant: |
            const stripeClient = require('stripe')('sk_test_key');

    - title: "Wrap Stripe API Calls with Timing and Outcome Logging"
      severity: Medium
      required_context: Application Observability, Stripe Integration
      software_version: all
      reference_link:
        - https://docs.stripe.com
      description: |
        Stripe API requests must be wrapped in structured code blocks that log both the latency and outcome (success or error) of the request.
      impact: |
        - Encourages consistent observability for Stripe integrations
        - Facilitates latency tracking and error analysis
        - Improves debugging visibility for payment-related operations
      code_examples:
        # JavaScript — COMPLIANT: Logs latency and outcome using try-catch and timestamp
        - compliant: |
            const startTime = Date.now();
            try {
              const customer = await stripe.customers.create({ email: "user@example.com" });
              const latency = Date.now() - startTime;
              console.log({ endpoint: "customers.create", latency, success: true });
            } catch (error) {
              const latency = Date.now() - startTime;
              console.error({
                endpoint: "customers.create",
                latency,
                success: false,
                error: error.message
              });
            }

        # JavaScript — NON-COMPLIANT: No timing or outcome logging for Stripe API call
        - non_compliant: |
            const customer = await stripe.customers.create({ email: "user@example.com" });

  - name: "Code Structure & Domain Modeling"
    paths:
      - "**/payments/**/*.py"
      - "**/stripe/**/*.py"
      - "**/services/payment_*.py"
      - "**/domain/**/*.py"
      - "**/use_cases/payment*.py"
    policies:
    - title: "Encapsulate Payment Logic Behind Service Classes"
      description: |
        Centralize all Stripe-related logic in dedicated service classes or modules rather than calling the Stripe SDK directly from controllers, views, or jobs.
      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Payment Architecture, Stripe SDK Usage
      severity: Medium
      impact: |
        - Improves code organization and separation of concerns  
        - Enables easier testing, mocking, and observability of Stripe logic  
        - Prevents duplication and inconsistencies across the codebase
      code_examples:
        # language: python
        - compliant: |
            # services/stripe_payment_service.py
            import stripe

            class StripePaymentService:
                def __init__(self, api_key):
                    stripe.api_key = api_key

                def charge_customer(self, customer_id, amount):
                    return stripe.Charge.create(
                        customer=customer_id,
                        amount=amount,
                        currency="usd"
                    )

            # controller.py
            service = StripePaymentService(api_key="sk_test_...")
            service.charge_customer(customer_id, 1000)
        - non_compliant: |
            # controller.py — Stripe logic directly embedded
            import stripe

            stripe.api_key = "sk_test_..."
            stripe.Charge.create(customer=customer_id, amount=1000, currency="usd")

    - title: "Map Stripe IDs to Internal Domain Entities"
      description: |
        Persist Stripe resource IDs (e.g., `cus_123`, `pi_456`) in internal domain models such as `Customer`, `Invoice`, or `Transaction`.  
        Store these IDs in dedicated database fields.  
        Do not use Stripe IDs as application-level primary keys.  
        Maintain an explicit mapping between Stripe objects and internal entities.
      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Stripe API Integration, Domain Modeling, Data Persistence
      severity: High
      impact: |
        - Decouples business logic from Stripe’s external data model  
        - Enables easier debugging and auditing of financial flows  
        - Supports retries, reconciliation, and fraud reviews through internal linking  
        - Prevents misidentification due to transient or duplicated Stripe data
      code_examples:
        # language: python
        - compliant: |
            class Customer(models.Model):
                user = models.OneToOneField(User, on_delete=models.CASCADE)
                stripe_customer_id = models.CharField(max_length=64, unique=True)  # Stores cus_123

            def create_stripe_customer(user):
                stripe_customer = stripe.Customer.create(email=user.email)
                Customer.objects.create(user=user, stripe_customer_id=stripe_customer["id"])
        - non_compliant: |
            # Fetching Stripe customer each time without storing its ID internally
            def charge_user(user):
                stripe.Customer.list(email=user.email)  # No persisted ID; prone to mismatch or multiple records

    - title: "Isolate Stripe SDK Calls from Domain Logic"
      description: |
        Encapsulate all Stripe SDK and API interactions within dedicated service classes instead of mixing them with domain or business logic.
      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Payment Flows, Domain Logic, External API Integration
      severity: High
      impact: |
        - Enhances unit test coverage and reduces dependency on external services during testing  
        - Avoids tightly coupling your domain model to a third-party SDK  
        - Improves flexibility and maintainability of billing and payment workflows  
      code_examples:
        # Python — COMPLIANT: Stripe SDK interaction isolated in a dedicated service class
        - compliant: |
            class StripeService:
                def refund_payment_intent(self, payment_intent_id):
                    stripe.Refund.create(payment_intent=payment_intent_id)

            class RefundPolicy:
                def should_auto_refund(self, order):
                    return order.status == "canceled" and not order.refunded

            class BillingManager:
                def __init__(self, stripe_service: StripeService):
                    self.stripe_service = stripe_service

                def issue_refund(self, order):
                    if RefundPolicy().should_auto_refund(order):
                        self.stripe_service.refund_payment_intent(order.payment_intent_id)

        # Python — NON-COMPLIANT: Stripe SDK call is directly tied with business logic
        - non_compliant: |
            def cancel_order(order):
                if order.status == "canceled" and not order.refunded:
                    stripe.Refund.create(payment_intent=order.payment_intent_id)

    - title: "Use Domain-Driven Design for Billing Workflows"
      description: |
        Model billing concepts such as Plan, Subscription, and Invoice as domain entities in your own application.
        Avoid using Stripe objects directly to represent business models or billing logic.
        Treat Stripe SDK as an infrastructure detail that persists domain state externally.

      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Billing System Design, Stripe Integration Abstraction
      severity: High
      impact: |
        - Aligns codebase with business language and real-world use cases
        - Reduces coupling to Stripe-specific models, enabling future migration flexibility
        - Promotes testable and reusable billing logic
      code_examples:
        # language: python
        - compliant: |
            class Subscription:
                def __init__(self, user, plan):
                    self.user = user
                    self.plan = plan
                    self.status = "active"

                def cancel(self):
                    self.status = "canceled"
                    StripeSubscriptionService.cancel_subscription(self)

            class StripeSubscriptionService:
                @staticmethod
                def cancel_subscription(subscription):
                    stripe.Subscription.modify(subscription.stripe_id, cancel_at_period_end=True)
        - non_compliant: |
            # Stripe object used directly as the business logic container
            def cancel_subscription(subscription_id):
                subscription = stripe.Subscription.retrieve(subscription_id)
                if subscription.status == "active":
                    stripe.Subscription.modify(subscription_id, cancel_at_period_end=True)

    - title: "Abstract External Dependencies for Testing"
      description: |
        Encapsulate all Stripe SDK calls in a wrapper or interface.
      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Testability, Stripe SDK Usage
      severity: High
      impact: |
        - Enables fast, deterministic, and isolated tests
        - Prevents accidental live API calls in test environments
        - Makes it easier to substitute Stripe with another provider if needed
      code_examples:
        # language: python
        - compliant: |
            class StripeClient:
                def create_charge(self, amount, customer_id):
                    return stripe.Charge.create(
                        amount=amount,
                        currency="usd",
                        customer=customer_id
                    )

            class PaymentService:
                def __init__(self, gateway):
                    self.gateway = gateway

                def charge_customer(self, user, amount):
                    return self.gateway.create_charge(amount, user.stripe_customer_id)

            # In tests
            mock_gateway = MagicMock()
            payment_service = PaymentService(mock_gateway)
            payment_service.charge_customer(user, 1000)
            mock_gateway.create_charge.assert_called_once()
        - non_compliant: |
            def charge_customer(user, amount):
                # Hard-coded Stripe call makes testing difficult
                return stripe.Charge.create(
                    amount=amount,
                    currency="usd",
                    customer=user.stripe_customer_id
                )

    - title: "Centralize Error Handling and Logging"
      description: |
        Stripe-related exceptions must be caught and handled within service classes. These services should standardize error responses and log relevant context.
      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Stripe Integration, Exception Handling
      severity: High
      impact: |
        - Promotes consistent error behavior across all payment operations
        - Simplifies debugging and observability
        - Prevents exception leakage from Stripe SDK into domain or UI logic
      code_examples:
        # language: python
        - compliant: |
            class StripeService:
                def create_charge(self, amount, customer_id):
                    try:
                        return stripe.Charge.create(
                            amount=amount,
                            currency="usd",
                            customer=customer_id
                        )
                    except stripe.error.CardError as e:
                        logger.warning(f"Card declined for customer {customer_id}: {str(e)}")
                        raise PaymentDeclinedError("Card was declined.")
                    except stripe.error.StripeError as e:
                        logger.error(f"Stripe API error: {str(e)}", exc_info=True)
                        raise PaymentProcessingError("Something went wrong with Stripe.")
        - non_compliant: |
            def create_charge(amount, customer_id):
                # No error handling — Stripe exceptions propagate directly
                return stripe.Charge.create(
                    amount=amount,
                    currency="usd",
                    customer=customer_id
                )

    - title: "Follow Clear Naming Conventions"
      description: |
        Use domain-driven names for methods, variables, and services instead of Stripe-specific terminology.

      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Stripe Integration, Code Structure
      severity: Medium
      impact: |
        - Improves code readability and maintainability
        - Makes business logic easier to understand for non-Stripe engineers
        - Simplifies future migration away from Stripe, if needed
      code_examples:
        # language: python
        - compliant: |
            def create_customer_profile(user_id, email):
                # Internally uses Stripe, but name reflects business action
                return stripe.Customer.create(email=email, metadata={"user_id": user_id})
        - non_compliant: |
            def create_stripe_customer(user_id, email):
                # Leaks provider name into business logic
                return stripe.Customer.create(email=email, metadata={"user_id": user_id})

    - title: "Maintain Stripe-Specific Mappings Separately"
      description: |
        Store all Stripe-specific identifiers and values in centralized configuration files or constants instead of hardcoding them throughout the codebase.

      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Stripe Integration, Configuration Management
      severity: Medium
      impact: |
        - Simplifies updates when Stripe values change (e.g., new price ID)
        - Improves maintainability and reduces risk of misconfiguration
        - Makes business logic easier to read and test
      code_examples:
        # language: python
        - compliant: |
            # stripe_constants.py
            PRICE_IDS = {
                "basic_plan": "price_123abc",
                "pro_plan": "price_456def"
            }

            # usage
            stripe.Subscription.create(customer=cus_id, items=[{"price": PRICE_IDS["pro_plan"]}])
        - non_compliant: |
            # Hardcoded price ID in logic
            stripe.Subscription.create(customer=cus_id, items=[{"price": "price_456def"}])

  - name: "Compliance & Data Privacy"
    paths:
      - "**/compliance/**/*.py"
      - "**/compliance/**/*.ts"
      - "**/compliance/**/*.js"
      - "**/compliance/**/*.md"
      - "**/compliance/**/*.html"
      - "**/compliance/**/*.htm"

      - "**/privacy/**/*.py"
      - "**/privacy/**/*.ts"
      - "**/privacy/**/*.js"
      - "**/privacy/**/*.md"
      - "**/privacy/**/*.html"
      - "**/privacy/**/*.htm"

      - "**/gdpr/**/*.py"
      - "**/gdpr/**/*.ts"
      - "**/gdpr/**/*.js"
      - "**/gdpr/**/*.md"
      - "**/gdpr/**/*.html"
      - "**/gdpr/**/*.htm"

      - "**/ccpa/**/*.py"
      - "**/ccpa/**/*.ts"
      - "**/ccpa/**/*.js"
      - "**/ccpa/**/*.md"
      - "**/ccpa/**/*.html"
      - "**/ccpa/**/*.htm"

      - "**/security/**/*.py"
      - "**/security/**/*.ts"
      - "**/security/**/*.js"
      - "**/security/**/*.md"
      - "**/security/**/*.html"
      - "**/security/**/*.htm"

      - "**/legal/**/*.py"
      - "**/legal/**/*.ts"
      - "**/legal/**/*.js"
      - "**/legal/**/*.md"
      - "**/legal/**/*.html"
      - "**/legal/**/*.htm"

      - "**/stripe/**/*.py"
      - "**/stripe/**/*.ts"
      - "**/stripe/**/*.js"

      - "**/config/**/*compliance*.py"
      - "**/config/**/*compliance*.ts"
      - "**/config/**/*compliance*.js"

      - "**/middleware/**/*security*.py"
      - "**/middleware/**/*security*.ts"
      - "**/middleware/**/*security*.js"

      - "**/utils/**/*redact*.py"
      - "**/utils/**/*redact*.ts"
      - "**/utils/**/*redact*.js"

      - "**/static/pages/**/*.md"
      - "**/static/pages/**/*.html"
      - "**/static/pages/**/*.htm"

      - "**/docs/**/*.md"
      - "**/docs/**/*.html"
      - "**/docs/**/*.htm"

      - "**/*dpa*.yml"
      - "**/*dpa*.yaml"
      - "**/*dpa*.json"

      - "**/*privacy*.yml"
      - "**/*privacy*.yaml"
      - "**/*privacy*.json"

      - "**/*compliance*.yml"
      - "**/*compliance*.yaml"
      - "**/*compliance*.json"
    policies:
    - title: "Delete Stripe Customers on User Deletion"
      description: |
        When a user deletion request is received, delete the corresponding Stripe customer using `stripe.Customer.delete`.
      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: User Data Deletion
      severity: High
      impact: |
        - Ensures customer data is not retained unnecessarily  
        - Supports data privacy compliance  
      code_examples:
        # Python — COMPLIANT: Deletes Stripe customer with error handling during user deletion
        - compliant: |
            import stripe

            def delete_user_and_customer(user):
                try:
                    if user.stripe_customer_id:
                        stripe.Customer.delete(user.stripe_customer_id)
                    # Proceed with user deletion in your system
                    delete_user_from_db(user.id)
                except stripe.error.StripeError as e:
                    logger.error(f"Failed to delete Stripe customer: {e}")
                    raise

        # Python — NON-COMPLIANT: User deleted but Stripe customer remains
        - non_compliant: |
            def delete_user_and_customer(user):
                # Deletes user but doesn't remove associated Stripe customer
                delete_user_from_db(user.id)

    - title: "Log Stripe Customer Redaction on User Deletion"
      description: |
        When deleting a user, include a logging statement indicating that the associated Stripe customer record is being redacted or deleted. This enables traceability of deletion actions in the codebase.
      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: User Data Deletion
      severity: High
      impact: |
        - Ensures Stripe-related deletion actions are visible in logs
        - Supports compliance and audit visibility from codebase
        - Avoids silent deletion of third-party data without traceability
      code_examples:
        # Python — COMPLIANT: Logs Stripe customer redaction intent clearly
        - compliant: |
            import logging

            def delete_user(user):
                if user.stripe_customer_id:
                    logging.info(f"Initiating deletion of Stripe customer: {user.stripe_customer_id}")
                    stripe.Customer.delete(user.stripe_customer_id)
                delete_user_from_db(user.id)

        # Python — NON-COMPLIANT: Stripe customer deleted silently with no log trace
        - non_compliant: |
            def delete_user(user):
                if user.stripe_customer_id:
                    stripe.Customer.delete(user.stripe_customer_id)
                delete_user_from_db(user.id)

    - title: "Enforce Retention Periods for Stripe Data"
      description: |
        Define and enforce explicit retention periods for Stripe customer records, payment methods, and invoices.
      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Data Privacy, Compliance
      severity: High
      impact: |
        - Ensures data is not stored longer than necessary
        - Supports data minimization obligations under GDPR and CCPA
      code_examples:
        # Python — COMPLIANT: Deletes customers inactive for more than 2 years
        - compliant: |
            import stripe
            from datetime import datetime, timedelta

            RETENTION_PERIOD_YEARS = 2
            cutoff_date = datetime.now() - timedelta(days=RETENTION_PERIOD_YEARS * 365)

            def enforce_retention(customers):
                for customer in customers:
                    last_active = datetime.fromtimestamp(customer.metadata.get("last_active", 0))
                    if last_active < cutoff_date:
                        stripe.Customer.delete(customer.id)
        
            # Assume you’ve already fetched customers and enriched metadata
            # with last_active timestamps

        # Python — NON-COMPLIANT: No enforcement of retention logic
        - non_compliant: |
            import stripe

            def fetch_all_customers():
                return stripe.Customer.list(limit=100)

            def process_customers():
                customers = fetch_all_customers()
                for customer in customers:
                    # No check for age or deletion
                    continue

    - title: "Use Timestamp-Based Deletion Logic for Stripe Records"
      description: |
        When implementing Stripe cleanup code, include logic that compares stored timestamps (e.g., last activity) against a fixed threshold, and conditionally deletes records using the Stripe API.
      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Data Cleanup Automation
      severity: Medium
      impact: |
        - Encourages maintainable cleanup logic using verifiable patterns
        - Promotes use of timestamp-based filtering for Stripe data
        - Ensures deletion logic is traceable and testable in code reviews
      code_examples:
        # Python — COMPLIANT: Deletes customers based on static timestamp threshold
        - compliant: |
            import stripe
            from datetime import datetime, timedelta

            THRESHOLD = timedelta(days=365)
            now = datetime.now()

            def cleanup_customers(customers):
                for customer in customers:
                    last_active_str = customer.metadata.get("last_active")
                    if last_active_str:
                        last_active = datetime.fromisoformat(last_active_str)
                        if now - last_active > THRESHOLD:
                            stripe.Customer.delete(customer.id)

        # Python — NON-COMPLIANT: Loads customers but does not apply timestamp filtering or deletion
        - non_compliant: |
            import stripe

            def cleanup_customers(customers):
                for customer in customers:
                    print(f"Customer {customer.id} loaded")  # No filtering or deletion logic

    - title: "Track Data Expiration Using Metadata"
      description: |
        Use Stripe object metadata to mark records with expiration or deletion status.
      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Stripe Metadata Usage
      severity: Medium
      impact: |
        - Enables automated cleanup based on metadata flags
        - Allows internal tooling to surface stale records
      code_examples:
        # Python — COMPLIANT: Marks for deletion
        - compliant: |
            import stripe

            # Properly marks customer with deletion metadata
            stripe.Customer.modify(
                "cus_123",
                metadata={"marked_for_deletion": "true"}
            )

        # Python — NON-COMPLIANT: Updates customer without metadata
        - non_compliant: |
            import stripe

            # Customer is updated but no metadata used for lifecycle tracking
            stripe.Customer.modify(
                "cus_123",
                description="Updated customer name"
            )

    - title: "Anonymize or Delete Stripe Customer Data Based on Metadata Flags"
      description: |
        Use metadata flags on Stripe objects to trigger anonymization or deletion of customer data.
      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Post-Billing Data Lifecycle
      severity: High
      impact: |
        - Limits risk of sensitive data exposure
        - Helps fulfill data erasure rights under privacy regulations
      code_examples:
        # Python — COMPLIANT: Deletes customer based on 'marked_for_deletion' flag
        - compliant: |
            import stripe

            customer = stripe.Customer.retrieve("cus_123")
            if customer.metadata.get("marked_for_deletion") == "true":
                stripe.Customer.delete("cus_123")

        # Python — NON-COMPLIANT: Accesses customer but does not act on metadata flag
        - non_compliant: |
            import stripe

            customer = stripe.Customer.retrieve("cus_123")
            print("Customer email:", customer.email)

    - title: "Declare Processing Purpose in Code or Configuration"
      description: |
        Define the purpose of payment data processing (e.g., checkout, subscription renewal) in code, configuration files, or environment variables, and reference it during Stripe charge creation or subscription handling.
      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Payment Flow Logic, Data Classification
      severity: Medium
      impact: |
        - Makes data processing purpose explicit for auditing
        - Enables static analysis for privacy compliance workflows
      code_examples:
        # Python — COMPLIANT: Declares processing purpose and uses it in charge metadata
        - compliant: |
            import os
            import stripe

            stripe.api_key = os.getenv("STRIPE_SECRET_KEY")
            PROCESSING_PURPOSES = {
                "checkout": "purchase",
                "auto_renewal": "subscription"
            }

            def process_payment(user_id, amount, context):
                purpose = PROCESSING_PURPOSES.get(context, "unspecified")
                stripe.Charge.create(
                    amount=amount,
                    currency="usd",
                    customer=user_id,
                    metadata={"processing_purpose": purpose}
                )

        # Python — NON-COMPLIANT: No processing purpose declared or used
        - non_compliant: |
            import stripe

            def process_payment(user_id, amount):
                stripe.Charge.create(
                    amount=amount,
                    currency="usd",
                    customer=user_id
                    # No metadata to describe processing purpose
                )

    - title: "Reference Processing Purpose in Payment Logic"
      description: |
        Ensure each payment-related action in your application includes a code-level reference to the processing purpose or reason for the data operation.
      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Payment Flow Logic, Audit-Friendly Design
      severity: Medium
      impact: |
        - Helps trace and audit data flows related to payment processing
        - Encourages consistent tagging of intent across the codebase
      code_examples:
        # Python — COMPLIANT: Includes processing reason for audit
        - compliant: |
            def charge_user(user_id):
                processing_reason = "checkout"
                log_payment_action(user_id, processing_reason)
                process_stripe_payment(user_id)

        # Python — NON-COMPLIANT: Omits processing reason entirely
        - non_compliant: |
            def charge_user(user_id):
                process_stripe_payment(user_id)

    - title: "Include Processing Purpose in Metadata or Request Context"
      description: |
        Include a processing purpose (e.g., "checkout", "subscription") in Stripe metadata fields or application request context for all payment-related operations.
      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Auditing & Traceability
      severity: Medium
      impact: |
        - Improves traceability of payment actions across systems
        - Enables static validation of business intent in code
      code_examples:
        # Python — COMPLIANT: Includes purpose in Stripe metadata
        - compliant: |
            stripe.PaymentIntent.create(
                amount=1000,
                currency="usd",
                metadata={"processing_purpose": "checkout"}
            )

        # Python — NON-COMPLIANT: Omits purpose from metadata
        - non_compliant: |
            stripe.PaymentIntent.create(
                amount=1000,
                currency="usd"
            )

    - title: "Avoid Storing Sensitive Cardholder Data"
      description: |
        Never store sensitive cardholder data such as full card numbers, CVC codes, or magnetic stripe data on your servers or in your database.

      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: PCI Compliance, Payment Flow Implementation
      severity: Critical
      impact: |
        - Minimizes PCI DSS compliance burden
        - Protects users from card data breaches
        - Avoids legal and regulatory penalties
      code_examples:
        # JavaScript — COMPLIANT: Uses Stripe Elements to tokenize card data
        - compliant: |
            const card = elements.create("card");
            card.mount("#card-element");

            const { token } = await stripe.createToken(card);
            await fetch("/charge", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ token: token.id })
            });

        # JavaScript — NON-COMPLIANT: Stores raw card details directly
        - non_compliant: |
            db.save({
              card_number: "4242424242424242",
              cvc: "123",
              expiry: "12/26"
            });

    - title: "Avoid Logging Personal Identifiable Information (PII)"
      description: |
        Do not log personal identifiable information such as names, email addresses, or card details in application logs.  
        Ensure logs only contain non-sensitive operational data and identifiers like customer ID or status codes.
      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Logging, Observability, Compliance
      severity: High
      impact: |
        - Reduces risk of PII exposure in breach scenarios
        - Ensures compliance with GDPR, CCPA, and PCI DSS
        - Improves audit readiness and protects user privacy
      code_examples:
        # JavaScript — COMPLIANT: Logs charge status without exposing PII
        - compliant: |
            logger.info("Charge created", {
              customer_id: customer.id,
              amount: charge.amount,
              status: charge.status
            })

        # JavaScript — NON-COMPLIANT: Logs sensitive PII including name, email, and card last4
        - non_compliant: |
            logger.info("Charge created for user", {
              name: customer.name,
              email: customer.email,
              card: charge.payment_method_details.card.last4
            })

    - title: "Implement Export Functionality for Stripe User Data"
      description: |
        Provide a function or method that retrieves and structures a user's Stripe-related data—such as customer profile, charges, and refunds—using the Stripe API.
      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Data Portability Implementation, Stripe Integration
      severity: High
      impact: |
        - Encourages consistent user data access patterns
        - Supports structured export for auditing or migration
        - Makes data access logic testable and reusable
      code_examples:
        # Python — COMPLIANT: Exports customer, charge, and refund data via Stripe API
        - compliant: |
            def export_stripe_user_data(customer_id):
                customer = stripe.Customer.retrieve(customer_id)
                charges = stripe.Charge.list(customer=customer_id)
                refunds = stripe.Refund.list(customer=customer_id)
                return {
                    "customer": customer,
                    "charges": list(charges.auto_paging_iter()),
                    "refunds": list(refunds.auto_paging_iter())
                }

        # Python — NON-COMPLIANT: Only returns partial data and in raw format
        - non_compliant: |
            def export_stripe_user_data(customer_id):
                # Returns only the customer ID without useful export details
                return {"customer_id": customer_id}

    - title: "Encrypt Stripe API Communication Using HTTPS and TLS"
      description: |
        All communication with Stripe’s API must use HTTPS with TLS version 1.2 or higher.
      software_version: all
      reference_link:
        - https://stripe.com/docs/security
      required_context: Payment Data Security, PCI Compliance
      severity: High
      impact: |
        - Aligns with PCI DSS and industry security standards
        - Reduces risk of interception and data breach
        - Ensures secure handling of payment-related information
      code_examples:
        # Python — COMPLIANT: Uses verified HTTPS client and secure API endpoint
        - compliant: |
            import stripe
            stripe.default_http_client = stripe.http_client.RequestsClient(
                verify_ssl_certs=True
            )
            stripe.api_base = "https://api.stripe.com"

        # Python — NON-COMPLIANT: Uses unencrypted HTTP and skips SSL verification
        - non_compliant: |
            import stripe
            stripe.default_http_client = stripe.http_client.RequestsClient(
                verify_ssl_certs=False
            )
            stripe.api_base = "http://api.stripe.com"

    - title: "Define DPA Acceptance Fields in Configuration"
      description: |
        Define fields for Stripe DPA acceptance—such as agreement version and acceptance date—in a configuration or compliance manifest file.
      software_version: all
      reference_link:
        - https://stripe.com/legal/dpa
      required_context: Configuration Management, Deployment Compliance
      severity: Medium
      impact: |
        - Enables automated detection of required legal metadata
        - Standardizes DPA-related fields across environments
        - Facilitates compliance metadata propagation in CI/CD
      code_examples:
        # YAML — COMPLIANT: Configuration file includes DPA metadata fields
        - compliant: |
            stripe_compliance:
              dpa_accepted: true
              dpa_version: "2024-04-01"
              accepted_on: "2025-06-15"

        # YAML — NON-COMPLIANT: Missing DPA metadata fields
        - non_compliant: |
            stripe_compliance:
              dpa_accepted: false

    - title: "Reference Stripe in Designated Disclosure Files"
      description: |
        All user-facing content files located in known legal or policy directories (e.g., `/legal/`, `/privacy/`, `/static/pages/`) must include a reference to Stripe as the payment processor when Stripe is used for processing payments.
      software_version: all
      reference_link:
        - https://stripe.com/privacy
      required_context: Static Disclosure File Locations
      severity: Medium
      impact: |
        - Ensures transparency through Stripe-specific disclosure
        - Allows automated validation via static file scanning
        - Reduces risk of incomplete third-party notices
      code_examples:
        # Markdown — COMPLIANT: Includes Stripe reference in static content
        - compliant: |
            ## Payment Processor
            We use Stripe to process payments. Stripe may collect personal data like your name, email, and payment method.
            See [Stripe’s Privacy Policy](https://stripe.com/privacy) for more information.

        # Markdown — NON-COMPLIANT: Omits Stripe reference in expected file
        - non_compliant: |
            ## Payment Processor
            We process payments securely and efficiently.

    - title: "Log Sensitive Stripe API Calls with Defined Utility"
      description: |
        All Stripe API calls that retrieve or modify personal data (e.g., customer, charge, or refund records) must be enclosed in a function that also invokes a specifically named logging function such as `log_stripe_access`, `audit_log`, or `track_sensitive_call`.
      software_version: all
      reference_link:
        - https://stripe.com/docs/security
      required_context: Sensitive Stripe API Usage
      severity: High
      impact: |
        - Ensures consistent auditing of access to personal data
        - Enables static analysis for enforcement
        - Promotes reusability and traceability of Stripe interactions
      code_examples:
        # Python — COMPLIANT: Stripe call wrapped with named logging function
        - compliant: |
            def get_customer_with_audit(customer_id, user_id):
                log_stripe_access(user_id, endpoint="/customers/retrieve", action="read")
                return stripe.Customer.retrieve(customer_id)

            def log_stripe_access(user_id, endpoint, action):
                print(f"Audit: {user_id} called {endpoint} for {action}")

        # Python — NON-COMPLIANT: Stripe API call without required logging
        - non_compliant: |
            def get_customer(customer_id):
                return stripe.Customer.retrieve(customer_id)

  - name: "Documentation & Typed Sdks"

    paths:
      - '**/*.ts'
      - '**/*.tsx'
      - '**/*.js'
      - '**/*.jsx'
      - '**/*.py'
      - '**/*.java'
      - '**/*.rb'
      - "docs/**/*.md"
      - "src/**/stripe*.ts"
      - "src/**/stripe*.py"
    policies:
    - title: "Use Official Stripe SDKs"
      description: |
        Use officially maintained Stripe SDKs such as `stripe-node`, `stripe-python`, `@stripe/stripe-js`, or `stripe-java` when integrating with Stripe APIs. Do not use raw HTTP requests or unofficial libraries.
      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Stripe API Integration, SDK Usage
      severity: Medium
      impact: |
        - Reduces risk of integration errors
        - Ensures compatibility with Stripe features and updates
      code_examples:
        # JavaScript — COMPLIANT: Uses official Stripe SDK
        - compliant: |
            import Stripe from 'stripe';
            const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, { apiVersion: '2023-10-16' });
            const customer = await stripe.customers.create({ email: 'user@example.com' });

        # JavaScript — NON-COMPLIANT: Uses raw HTTP request
        - non_compliant: |
            fetch('https://api.stripe.com/v1/customers', {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${process.env.STRIPE_SECRET_KEY}`
              },
              body: new URLSearchParams({ email: 'user@example.com' })
            });

    - title: "Pin Stripe SDK Versions"
      description: |
        Pin the version of the Stripe SDK in your project's dependency manager.
      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Dependency Management, SDK Usage
      severity: Medium
      impact: |
        - Prevents unexpected behavior from unreviewed upgrades
        - Supports reproducible builds
      code_examples:
        # JavaScript — COMPLIANT: Stripe version pinned in package.json
        - compliant: |
            {
              "dependencies": {
                "stripe": "12.14.0"
              }
            }

        # JavaScript — NON-COMPLIANT: Version not pinned (uses ^)
        - non_compliant: |
            {
              "dependencies": {
                "stripe": "^12.14.0"
              }
            }

    - title: "Use Typed Stripe SDK Features"
      description: |
        Use type-safe configuration and typed methods provided by official Stripe SDKs where supported.
      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: TypeScript, Stripe SDK Integration
      severity: Low
      impact: |
        - Enables compiler-time validation
        - Improves code reliability and developer experience
      code_examples:
        # TypeScript — COMPLIANT: Uses typed Stripe SDK with validated environment variable
        - compliant: |
            import Stripe from 'stripe';

            const stripeApiKey = process.env.STRIPE_SECRET_KEY;
            if (!stripeApiKey) {
              throw new Error("STRIPE_SECRET_KEY is not defined in environment variables.");
            }

            const stripe = new Stripe(stripeApiKey, {
              apiVersion: '2023-10-16',
            });

            const customerParams: Stripe.CustomerCreateParams = {
              email: 'user@example.com',
              name: 'John Doe',
            };

            const customer: Stripe.Response<Stripe.Customer> = await stripe.customers.create(customerParams);

        # JavaScript — NON-COMPLIANT: Lacks typing and proper validation
        - non_compliant: |
            const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);

            const customer = await stripe.customers.create({
              email: 'user@example.com',
              name: 'John Doe'
            });

    - title: "Wrap Stripe SDK Calls in Reusable Client or Service Module"
      description: |
        Encapsulate Stripe SDK calls in a reusable client or service module instead of calling the SDK directly across the codebase.
      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Stripe SDK Integration, Abstraction Layers
      severity: Medium
      impact: |
        - Promotes centralized control over Stripe usage
        - Enables consistent mocking and logging
      code_examples:
        # TypeScript — COMPLIANT: Centralized client module for Stripe
        - compliant: |
            // stripeClient.ts
            import Stripe from 'stripe';
            const stripe = new Stripe(process.env.STRIPE_KEY, { apiVersion: '2023-10-16' });

            export const createCustomer = (email: string) => {
              return stripe.customers.create({ email });
            };

        # TypeScript — NON-COMPLIANT: Direct SDK usage inside business logic
        - non_compliant: |
            import Stripe from 'stripe';
            const stripe = new Stripe(process.env.STRIPE_KEY, { apiVersion: '2023-10-16' });

            async function registerUser(email: string) {
              // Stripe logic embedded in business layer
              const customer = await stripe.customers.create({ email });
              // More unrelated user registration logic follows...
            }

    - title: "Use Consistent Error Handling with Stripe SDK"
      description: |
        Stripe SDK calls must use centralized or clearly structured try/catch error handling to ensure predictable behavior and debugging.
      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Stripe Integration Standards
      severity: Medium
      impact: |
        - Improves maintainability of payment code
        - Reduces cognitive overhead across teams
      code_examples:
        # TypeScript — COMPLIANT: Reusable function with structured error handling
        - compliant: |
            export async function createStripeCustomer(email: string) {
              try {
                return await stripe.customers.create({ email });
              } catch (error) {
                throw new Error(`StripeError: ${error.message}`);
              }
            }

        # TypeScript — NON-COMPLIANT: Inline call with inconsistent error handling
        - non_compliant: |
            stripe.customers.create({ email }).catch(err => console.log(err));

    - title: "Document Architectural Decisions for Payment Modules in Code"
      description: |
        Annotate key architectural decisions in payment-related modules using structured code comments that explain context, decision rationale, and consequences.
      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Payment Flow Implementation
      severity: Low
      impact: |
        - Improves code readability
        - Preserves architectural intent close to implementation
      code_examples:
        # TypeScript — COMPLIANT: Inline comment documents architectural rationale
        - compliant: |
            // [ADR] Context: Subscription system requires secure PCI-compliant checkout.
            // [ADR] Decision: Using Stripe Checkout for hosted payment experience.
            // [ADR] Consequences: Limited customization, but faster integration.
            const session = await stripe.checkout.sessions.create({ ... });

        # TypeScript — NON-COMPLIANT: No context or decision rationale documented
        - non_compliant: |
            const session = await stripe.checkout.sessions.create({ ... });

    - title: "Use Verifiable Inline Comments for Payment Code"
      description: |
        Payment-related logic (e.g., charges, refunds, webhooks) must include inline comments with a recognizable reference pattern such as `See:`, `Ref:`, or `Docs:` followed by a URL or relative path.
      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Payment Flow Code, Developer Guidance
      severity: Medium
      impact: |
        - Helps developers locate relevant guidance for payment logic
        - Enables static checks for presence of documentation references
      code_examples:
        # JavaScript — COMPLIANT: Inline comment includes structured reference pattern
        - compliant: |
            // See: /docs/payments/refund_flow.md
            async function refundCharge(chargeId) {
              return await stripe.refunds.create({ charge: chargeId });
            }

        # JavaScript — NON-COMPLIANT: Missing recognizable comment reference
        - non_compliant: |
            async function refundCharge(chargeId) {
              return await stripe.refunds.create({ charge: chargeId });
            }

    - title: "Include Stripe API Doc Links Above Stripe Method Calls"
      description: |
        Include a link to the corresponding Stripe API documentation in a code comment directly above any Stripe SDK method call for PaymentIntents, Refunds, or Webhooks.
      software_version: all
      reference_link:
        - https://stripe.com/docs/api/payment_intents
        - https://stripe.com/docs/api/refunds
        - https://stripe.com/docs/webhooks
      required_context: Stripe API Usage
      severity: Low
      impact: |
        - Promotes discoverability of official API references
        - Helps developers verify and understand expected parameters and responses
      code_examples:
        # JavaScript — COMPLIANT: Stripe doc link above PaymentIntent
        - compliant: |
            // Stripe PaymentIntent API: https://stripe.com/docs/api/payment_intents
            const paymentIntent = await stripe.paymentIntents.create({
              amount: 2000,
              currency: 'usd',
              payment_method_types: ['card'],
              confirm: true,
            });

        # JavaScript — NON-COMPLIANT: No Stripe doc link
        - non_compliant: |
            const paymentIntent = await stripe.paymentIntents.create({
              amount: 2000,
              currency: 'usd',
              payment_method_types: ['card'],
              confirm: true,
            });

    - title: "Add Setup Reference Comment When Importing Stripe SDK"
      description: |
        When importing the Stripe SDK, include a nearby inline comment that references a setup guide using a recognizable pattern such as `Setup:` followed by a relative file path or link.
      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Stripe SDK Import, Developer Onboarding
      severity: Medium
      impact: |
        - Promotes discoverability of setup instructions
        - Enables consistent onboarding without relying on external file scanning
      code_examples:
        # JavaScript — COMPLIANT: Includes comment pointing to setup guide
        - compliant: |
            // Setup: docs/stripe/nodejs-setup.md
            import Stripe from 'stripe';

            const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
              apiVersion: '2023-10-16',
            });

        # JavaScript — NON-COMPLIANT: Missing setup reference comment
        - non_compliant: |
            import Stripe from 'stripe';

            const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
              apiVersion: '2023-10-16',
            });

    - title: "Use Typed Stripe API Responses"
      description: |
        When handling Stripe API responses in TypeScript or JavaScript, use explicit types or interfaces provided by the Stripe SDK to ensure type safety.

      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Stripe SDK Usage in TypeScript/JavaScript
      severity: Medium
      impact: |
        - Prevents bugs from untyped or loosely typed response handling
        - Improves IDE support, autocomplete, and validation
        - Supports maintainable and self-documenting code

      code_examples:
        # TypeScript — COMPLIANT: Uses Stripe's PaymentIntent type
        - compliant: |
            import { PaymentIntent } from '@stripe/stripe-js';

            async function handlePayment(intent: PaymentIntent) {
              if (intent.status === 'succeeded') {
                // proceed with fulfillment
              }
            }

        # TypeScript — NON-COMPLIANT: Uses 'any' type for intent
        - non_compliant: |
            async function handlePayment(intent: any) {
              if (intent.status === 'succeeded') {
                // proceed with fulfillment
              }
            }

    - title: "Use @stripe-change Annotation with Stripe SDK Integration"
      description: |
        Add an inline comment with the `@stripe-change` annotation near Stripe SDK initialization or API logic to document significant changes or customizations.
      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Stripe SDK Initialization or Integration Logic
      severity: Medium
      impact: |
        - Makes Stripe-related changes traceable in code
        - Supports static analysis and changelog generation
      code_examples:
        # TypeScript — COMPLIANT: Includes @stripe-change annotation
        - compliant: |
            // @stripe-change: updated to API version 2023-10-16
            const stripe = new Stripe(process.env.STRIPE_KEY, {
              apiVersion: '2023-10-16',
            });

        # TypeScript — NON-COMPLIANT: No change annotation
        - non_compliant: |
            const stripe = new Stripe(process.env.STRIPE_KEY, {
              apiVersion: '2023-10-16',
            });

  - name: "Continuous Delivery & Safe Migrations"
    paths:
      - "**/*.js"
      - "**/*.ts"
      - "**/*.tsx"
      - "**/*.json"
      - "**/*.yaml"
      - "**/*.yml"
      - "**/deploy/**/*.ts"
      - "**/deploy/**/*.js"
      - "**/migrations/**/*.ts"
      - "**/migrations/**/*.js"
      - "**/ci_cd/**/*.ts"
      - "**/ci_cd/**/*.js"
      - "**/infrastructure/**/*.ts"
      - "**/infrastructure/**/*.js"
      - ".github/pull_request_template.md"
      - ".github/*template*.md"
    policies:
    - title: "Feature Flag Usage for Payment Features"
      description: |
        All new billing or payment features must be conditionally gated using feature flags to ensure safe rollout. Wrapping payment logic in feature flags enables controlled deployment, experimentation, and rollback without modifying core logic.

      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Feature Management, Risk Mitigation
      severity: Medium
      impact: |
        - Reduces risk from deploying untested or unstable payment logic  
        - Enables controlled experimentation and fast rollback

      code_examples:
        # JavaScript — COMPLIANT: Payment feature gated by LaunchDarkly feature flag
        - compliant: |
            const is3dsEnabled = await ldClient.variation('enable-3ds', userContext, false);
            if (is3dsEnabled) {
              // Proceed with 3D Secure flow
            } else {
              // Fallback to legacy payment flow
            }

        # JavaScript — NON-COMPLIANT: New payment feature enabled directly without feature flag
        - non_compliant: |
            // Risky: No feature flag used, rollout cannot be controlled or reverted
            enable3DSecureFlow();

    - title: "Conditionally Gate High-Risk Code Paths"
      description: |
        Critical or high-risk logic changes must be conditionally gated using configuration flags or environment-based conditions. This allows partial exposure of new behavior to selected user segments, tenants, or environments, simulating a canary deployment strategy without requiring infra-specific guarantees.

      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Conditional Execution, Risk Mitigation
      severity: High
      impact: |
        - Enables safe rollout of risky logic by gating execution at runtime  
        - Avoids affecting all users simultaneously  
        - Allows selective testing and fast rollback

      code_examples:
        # Python — COMPLIANT: Code gated by tenant-level condition
        - compliant: |
            if tenant.is_in_canary_group:
                process_request_with_new_logic(data)
            else:
                process_request_with_stable_logic(data)

        # Python — NON-COMPLIANT: New logic runs for all users with no gating
        - non_compliant: |
            # This exposes all users to new, untested logic at once
            process_request_with_new_logic(data)

    - title: "Version Guards and Fallbacks for Stripe Integration Changes"
      description: |
        Stripe integration logic must include version-based guards and fallback handling to ensure safe execution of critical changes. For reversible operations (e.g. subscription updates), explicitly handle legacy or previous states in code to allow safe fallback behavior.

      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Stripe Integration Safety, Source-Controlled Logic
      severity: High
      impact: |
        - Prevents production failures due to incompatible version mismatches  
        - Enables runtime rollback via conditional logic  
        - Reduces risk of inconsistent billing or webhook handling

      code_examples:
        # JavaScript — COMPLIANT: Version guard and fallback behavior implemented
        - compliant: |
            // Version-aware handling for webhook event
            if (event.api_version === '2024-06-01') {
              handleNewWebhookLogic(event);
            } else {
              handleLegacyWebhookLogic(event);
            }

            // Explicit fallback to prior price on error
            try {
              await stripe.subscriptions.update(subscriptionId, {
                items: [{ price: newPriceId }],
              });
            } catch (err) {
              await stripe.subscriptions.update(subscriptionId, {
                items: [{ price: previousPriceId }],
                proration_behavior: 'none',
              });
            }

        # JavaScript — NON-COMPLIANT: No version awareness or error fallback
        - non_compliant: |
            // No version guards, no handling of potential rollback scenario
            await stripe.subscriptions.update(subscriptionId, {
              items: [{ price: newPriceId }],
            });

    - title: "Safe Schema and API Version Migrations"
      description: |
        Implement explicit API version checks in Stripe webhook handlers to conditionally process events based on their version.

      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: API Versioning, Webhook Handling, Schema Evolution
      severity: High
      impact: |
        - Avoids processing failures caused by unexpected schema changes
        - Allows phased migration across different API versions
        - Preserves compatibility with older event formats
        - Enables safer updates to webhook logic

      code_examples:
        # JavaScript — COMPLIANT: Version-guarded webhook logic and schema validation
        - compliant: |
            if (event.api_version === '2024-06-01') {
              processWebhookNewSchema(event);
            } else {
              processWebhookLegacySchema(event);
            }

            const knownFields = ['id', 'type', 'data', 'object'];
            Object.keys(event).forEach(key => {
              if (!knownFields.includes(key)) {
                console.warn(`Unknown webhook field detected: ${key}`);
              }
            });

        # JavaScript — NON-COMPLIANT: No version check or schema awareness
        - non_compliant: |
            // Unconditionally processes webhook, assumes a fixed schema
            processWebhook(event);

    - title: "Consistent Logging for Stripe Integration Errors"
      description: |
        Log all Stripe integration errors using a consistent and structured format to support post-deployment health monitoring.

      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Post-Deployment Monitoring, Incident Management
      severity: High
      impact: |
        - Enables early detection of regressions in Stripe payment flows  
        - Improves auditability and debugging of payment issues  
        - Facilitates targeted rollback based on structured error patterns

      code_examples:
        # JavaScript — COMPLIANT: Logs Stripe error with deployment version metadata
        - compliant: |
            try {
              await stripe.charges.create({ ... });
            } catch (err) {
              console.error('Stripe charge failed', {
                error: err.message,
                deployment: process.env.DEPLOY_VERSION,
                environment: process.env.NODE_ENV
              });
              throw err;
            }

        # JavaScript — NON-COMPLIANT: Stripe failure is caught but not logged or traced
        - non_compliant: |
            try {
              await stripe.charges.create({ ... });
            } catch (err) {
              // Fails silently with no logs or traceable error output
            }

    - title: "Use Stripe Test Keys in Non-Production Environments"
      description: |
        Always use Stripe test API keys in development, staging, and other non-production environments.

      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Environment Management
      severity: High
      impact: |
        - Avoids unintended real charges during testing  
        - Protects real customer and financial data in dev environments  
        - Reduces risk of exposing live credentials in unsafe contexts

      code_examples:
        # JavaScript — COMPLIANT: Uses test key for non-prod
        - compliant: |
            const stripe = new Stripe('sk_test_abc123', {
              apiVersion: '2023-10-16',
            });

        # JavaScript — NON-COMPLIANT: Uses live key in dev environment
        - non_compliant: |
            const stripe = new Stripe('sk_live_xyz456', {
              apiVersion: '2023-10-16',
            });

    - title: "Avoid Hardcoding Stripe API Keys"
      description: |
        Stripe API keys must be sourced from secure environment-specific configuration, not hardcoded in the source code.

      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Secure Configuration, Secret Management
      severity: High
      impact: |
        - Prevents accidental exposure of keys in version control  
        - Simplifies key rotation and environment-specific deployment  
        - Enhances overall application security posture

      code_examples:
        # JavaScript — COMPLIANT: API key is loaded from environment config
        - compliant: |
            const stripe = new Stripe(process.env.STRIPE_API_KEY, {
              apiVersion: '2023-10-16',
            });

        # JavaScript — NON-COMPLIANT: API key hardcoded in source file
        - non_compliant: |
            const stripe = new Stripe('sk_test_abc123', {
              apiVersion: '2023-10-16',
            });

    - title: "Version Control of Payment Configurations"
      description: |
        Store Stripe-related configuration such as product IDs, price mappings, tax rates, and webhook event types in version-controlled files. Avoid hardcoding these values in service logic. Use JSON, YAML, or environment-specific modules for configuration, and ensure configs are updated through code changes.

      software_version: all
      reference_link:
        - https://docs.stripe.com
      required_context: Configuration Management, Payment Reliability
      severity: Medium
      impact: |
        - Prevents errors caused by inconsistent or outdated Stripe values
        - Ensures configuration changes are reviewed, tracked, and testable
        - Supports safe promotion of payment settings across environments
        - Enables easier debugging and rollback in production incidents

      code_examples:
        # JavaScript — COMPLIANT: Payment config loaded from version-controlled JSON file
        - compliant: |
            // config/payment_config.json
            {
              "productId": "prod_ABC123",
              "priceMap": {
                "basic": "price_001",
                "pro": "price_002"
              },
              "taxRate": "txr_789",
              "webhookEvents": ["invoice.paid", "payment_intent.succeeded"]
            }

            // paymentService.js
            import paymentConfig from './config/payment_config.json' assert { type: 'json' };
            import Stripe from 'stripe';
            const stripe = new Stripe(process.env.STRIPE_API_KEY);

            async function getProPrice() {
              return await stripe.prices.retrieve(paymentConfig.priceMap.pro);
            }

        # JavaScript — NON-COMPLIANT: Hardcoded Stripe values in business logic
        - non_compliant: |
            import Stripe from 'stripe';
            const stripe = new Stripe(process.env.STRIPE_API_KEY);

            // Hardcoded product ID and event types scattered in code
            async function getProduct() {
              return await stripe.products.retrieve("prod_ABC123");
            }

            function handleEvent(event) {
              if (event.type === "invoice.paid" || event.type === "payment_intent.succeeded") {
                // ...
              }
            }

    - title: "Presence of Pull Request Template for Payment-Sensitive Code"
      description: |
        A version-controlled pull request template file must exist at `.github/pull_request_template.md` and contain checklist items related to Stripe or other payment integration changes.

      software_version: all
      reference_link:
        - https://docs.github.com/en/pull-requests/building-and-managing-pull-requests/about-pull-requests
      required_context: GitHub PR Templates, Payment Integration
      severity: Medium
      impact: |
        - Promotes consistent review standards for payment-related code
        - Encourages documentation of critical test, rollback, and compatibility factors
        - Helps prevent omissions in sensitive payment logic changes

      code_examples:
        # Markdown — COMPLIANT: Template exists and includes payment-specific checklist
        - compliant: |
            # .github/pull_request_template.md
            ## Payment Change Checklist
            - [ ] Have tests been added or updated?
            - [ ] Is there a rollback plan for this change?
            - [ ] Are version or schema changes accounted for?

        # Markdown — NON-COMPLIANT: No template file or no payment checklist
        - non_compliant: |
            # Either this file does not exist
            # OR it lacks any checklist related to payment integration or Stripe
    